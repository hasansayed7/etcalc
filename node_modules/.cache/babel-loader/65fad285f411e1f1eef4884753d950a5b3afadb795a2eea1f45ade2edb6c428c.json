{"ast":null,"code":"// Constants for financial calculations\nexport const FINANCIAL_CONSTANTS = {\n  ANNUAL_DISCOUNT_RATE: 0.03,\n  INDUSTRY_AVG_SERVICE_FEE: 100,\n  SERVICE_FEE_THRESHOLD_LOW: 0.8,\n  SERVICE_FEE_THRESHOLD_HIGH: 1.2,\n  TAX_RATE: 0.13,\n  DEFAULT_MARGIN: 0.35,\n  MIN_MARGIN: 0.20,\n  TARGET_MARGIN: 0.35,\n  HIGH_MARGIN: 0.40,\n  MIN_PROFIT_THRESHOLD: 200,\n  MIN_SERVICE_FEE: 100,\n  // Volume discount tiers\n  VOLUME_DISCOUNTS: [{\n    minQty: 5,\n    discount: 0.05\n  },\n  // 5% off for 5+ units\n  {\n    minQty: 10,\n    discount: 0.10\n  },\n  // 10% off for 10+ units\n  {\n    minQty: 20,\n    discount: 0.15\n  },\n  // 15% off for 20+ units\n  {\n    minQty: 50,\n    discount: 0.20\n  } // 20% off for 50+ units\n  ],\n  // Seasonal pricing periods\n  SEASONAL_PRICING: {\n    Q1: {\n      name: \"New Year Special\",\n      discount: 0.10,\n      months: [0, 1, 2]\n    },\n    // Jan-Mar\n    Q2: {\n      name: \"Spring Promotion\",\n      discount: 0.05,\n      months: [3, 4, 5]\n    },\n    // Apr-Jun\n    Q3: {\n      name: \"Summer Sale\",\n      discount: 0.15,\n      months: [6, 7, 8]\n    },\n    // Jul-Sep\n    Q4: {\n      name: \"Year-End Deal\",\n      discount: 0.20,\n      months: [9, 10, 11]\n    } // Oct-Dec\n  },\n  // Payment processing fee constants\n  PAYMENT_PROCESSING: {\n    BASE_FEE: 0.30,\n    PERCENTAGE_FEE: 0.0299,\n    MIN_AMOUNT_FOR_WAIVER: 1000,\n    // Minimum amount to qualify for fee waiver\n    ANNUAL_COMMITMENT_WAIVER: true,\n    // Whether annual commitments qualify for fee waiver\n    // Tiered processing fees based on monthly transaction volume\n    TIERED_FEES: [{\n      minVolume: 0,\n      baseFee: 0.30,\n      percentageFee: 0.0299\n    }, {\n      minVolume: 10000,\n      baseFee: 0.25,\n      percentageFee: 0.0275\n    }, {\n      minVolume: 50000,\n      baseFee: 0.20,\n      percentageFee: 0.0250\n    }, {\n      minVolume: 100000,\n      baseFee: 0.15,\n      percentageFee: 0.0225\n    }, {\n      minVolume: 500000,\n      baseFee: 0.10,\n      percentageFee: 0.0200\n    }]\n  },\n  // Customer loyalty tiers\n  LOYALTY_TIERS: {\n    BRONZE: {\n      name: \"Bronze\",\n      minSpend: 0,\n      benefits: {\n        processingFeeDiscount: 0,\n        serviceFeeDiscount: 0,\n        specialPromotions: false\n      }\n    },\n    SILVER: {\n      name: \"Silver\",\n      minSpend: 5000,\n      benefits: {\n        processingFeeDiscount: 0.25,\n        // 25% off processing fees\n        serviceFeeDiscount: 0.10,\n        // 10% off service fees\n        specialPromotions: true\n      }\n    },\n    GOLD: {\n      name: \"Gold\",\n      minSpend: 20000,\n      benefits: {\n        processingFeeDiscount: 0.50,\n        // 50% off processing fees\n        serviceFeeDiscount: 0.20,\n        // 20% off service fees\n        specialPromotions: true,\n        prioritySupport: true\n      }\n    },\n    PLATINUM: {\n      name: \"Platinum\",\n      minSpend: 50000,\n      benefits: {\n        processingFeeDiscount: 1.00,\n        // 100% off processing fees\n        serviceFeeDiscount: 0.30,\n        // 30% off service fees\n        specialPromotions: true,\n        prioritySupport: true,\n        dedicatedAccountManager: true\n      }\n    }\n  }\n};\n\n/**\r\n * Calculate volume discount based on quantity\r\n * @param {number} qty - Quantity\r\n * @returns {number} Discount percentage (0-1)\r\n */\nexport const calculateVolumeDiscount = qty => {\n  const applicableDiscount = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS.filter(tier => qty >= tier.minQty).sort((a, b) => b.discount - a.discount)[0];\n  return applicableDiscount ? applicableDiscount.discount : 0;\n};\n\n/**\r\n * Get current seasonal pricing period\r\n * @returns {Object} Seasonal pricing period info\r\n */\nexport const getCurrentSeasonalPricing = () => {\n  const currentMonth = new Date().getMonth();\n  return Object.values(FINANCIAL_CONSTANTS.SEASONAL_PRICING).find(period => period.months.includes(currentMonth)) || {\n    name: \"Standard Pricing\",\n    discount: 0\n  };\n};\n\n/**\r\n * Get pricing data for a product based on quantity\r\n * @param {Object} product - Product object\r\n * @param {number} qty - Quantity\r\n * @returns {Object} Pricing slab data with discounts applied\r\n * @throws {Error} If product or quantity is invalid\r\n */\nexport const getPricingData = (product, qty) => {\n  if (!product || !product.pricingSlabs) {\n    throw new Error('Invalid product data');\n  }\n  if (!Number.isInteger(qty) || qty < 1) {\n    throw new Error('Quantity must be a positive integer');\n  }\n\n  // Validate pricing slabs\n  product.pricingSlabs.forEach(slab => {\n    if (slab.unitCost < 0) {\n      throw new Error(`Invalid unit cost (${slab.unitCost}) for product ${product.name}`);\n    }\n    if (slab.margin < FINANCIAL_CONSTANTS.MIN_MARGIN) {\n      throw new Error(`Margin (${slab.margin}) below minimum threshold for product ${product.name}`);\n    }\n  });\n  const slab = product.pricingSlabs.find(slab => qty >= slab.minQty && qty <= slab.maxQty) || product.pricingSlabs[product.pricingSlabs.length - 1];\n\n  // Calculate discounts\n  const volumeDiscount = calculateVolumeDiscount(qty);\n  const seasonalPricing = getCurrentSeasonalPricing();\n  const totalDiscount = Math.min(volumeDiscount + seasonalPricing.discount, 0.30); // Cap total discount at 30%\n\n  // Apply discounts to recommended price\n  const discountedPrice = slab.recommendedPrice * (1 - totalDiscount);\n  return {\n    ...slab,\n    recommendedPrice: formatCurrency(discountedPrice),\n    volumeDiscount,\n    seasonalDiscount: seasonalPricing.discount,\n    totalDiscount,\n    seasonalPeriod: seasonalPricing.name\n  };\n};\n\n/**\r\n * Get package name based on number of products\r\n * @param {Array} products - Array of products\r\n * @returns {string} Package name\r\n */\nexport const getPackageName = products => {\n  if (!Array.isArray(products)) {\n    throw new Error('Invalid products array');\n  }\n  return products.length >= 2 ? \"Backup Total\" : \"Backup Basic\";\n};\n\n/**\r\n * Calculate total cost with proper decimal handling\r\n * @param {number} amount - Amount to format\r\n * @returns {number} Formatted amount with 2 decimal places\r\n */\nexport const formatCurrency = amount => {\n  if (typeof amount !== 'number' || isNaN(amount)) {\n    throw new Error('Invalid amount for currency formatting');\n  }\n  if (!isFinite(amount)) {\n    throw new Error('Amount must be a finite number');\n  }\n  return Number(Math.round(amount + 'e2') + 'e-2');\n};\n\n/**\r\n * Get customer loyalty tier based on total spend\r\n * @param {number} totalSpend - Total customer spend\r\n * @returns {Object} Loyalty tier details\r\n */\nexport const getLoyaltyTier = totalSpend => {\n  const tiers = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS).sort(([, a], [, b]) => b.minSpend - a.minSpend);\n  for (const [, tier] of tiers) {\n    if (totalSpend >= tier.minSpend) {\n      return tier;\n    }\n  }\n  return FINANCIAL_CONSTANTS.LOYALTY_TIERS.BRONZE;\n};\n\n/**\r\n * Get tiered processing fee based on monthly volume\r\n * @param {number} monthlyVolume - Monthly transaction volume\r\n * @returns {Object} Fee tier details\r\n */\nexport const getProcessingFeeTier = monthlyVolume => {\n  const tiers = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES.sort((a, b) => b.minVolume - a.minVolume);\n  for (const tier of tiers) {\n    if (monthlyVolume >= tier.minVolume) {\n      return tier;\n    }\n  }\n  return tiers[tiers.length - 1];\n};\n\n/**\r\n * Calculate payment processing fee\r\n * @param {number} amount - Transaction amount\r\n * @param {boolean} isAnnual - Whether this is an annual commitment\r\n * @param {boolean} waiveFees - Whether to waive the fees\r\n * @param {number} monthlyVolume - Monthly transaction volume\r\n * @param {number} totalSpend - Total customer spend\r\n * @returns {Object} Fee details\r\n */\nexport const calculatePaymentProcessingFee = (amount, isAnnual, waiveFees, monthlyVolume = 0, totalSpend = 0) => {\n  if (waiveFees) {\n    return {\n      fee: 0,\n      percentage: 0,\n      baseFee: 0,\n      isWaived: true,\n      reason: isAnnual ? \"Annual commitment\" : \"Fee waiver applied\"\n    };\n  }\n\n  // Get applicable fee tier\n  const feeTier = getProcessingFeeTier(monthlyVolume);\n  const baseFee = feeTier.baseFee;\n  const percentageFee = amount * feeTier.percentageFee;\n  const totalFee = baseFee + percentageFee;\n\n  // Get loyalty tier benefits\n  const loyaltyTier = getLoyaltyTier(totalSpend);\n  const loyaltyDiscount = loyaltyTier.benefits.processingFeeDiscount;\n  const discountedFee = totalFee * (1 - loyaltyDiscount);\n\n  // Check if amount qualifies for automatic waiver\n  const qualifiesForWaiver = amount >= FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER || isAnnual && FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.ANNUAL_COMMITMENT_WAIVER || loyaltyTier.name === \"PLATINUM\";\n  return {\n    fee: qualifiesForWaiver ? 0 : discountedFee,\n    percentage: feeTier.percentageFee,\n    baseFee,\n    isWaived: qualifiesForWaiver,\n    reason: qualifiesForWaiver ? isAnnual ? \"Annual commitment\" : loyaltyTier.name === \"PLATINUM\" ? \"Platinum tier benefit\" : \"Amount exceeds minimum threshold\" : \"Standard processing fee\",\n    loyaltyTier: loyaltyTier.name,\n    feeTier: `$${feeTier.minVolume.toLocaleString()}+`,\n    originalFee: totalFee,\n    loyaltyDiscount: loyaltyDiscount * 100\n  };\n};\n\n/**\r\n * Calculate total cost with all discounts and fees\r\n * @param {Object} product - Product object\r\n * @param {number} qty - Quantity\r\n * @param {boolean} isAnnual - Whether this is an annual commitment\r\n * @param {boolean} waiveFees - Whether to waive processing fees\r\n * @param {number} monthlyVolume - Monthly transaction volume\r\n * @param {number} totalSpend - Total customer spend\r\n * @returns {Object} Complete pricing details\r\n */\nexport const calculateTotalCost = (product, qty, isAnnual, waiveFees, monthlyVolume = 0, totalSpend = 0) => {\n  const pricingData = getPricingData(product, qty);\n  const subtotal = pricingData.recommendedPrice * qty;\n  const tax = subtotal * FINANCIAL_CONSTANTS.TAX_RATE;\n  const processingFee = calculatePaymentProcessingFee(subtotal + tax, isAnnual, waiveFees, monthlyVolume, totalSpend);\n  const loyaltyTier = getLoyaltyTier(totalSpend);\n  return {\n    subtotal,\n    tax,\n    processingFee: processingFee.fee,\n    total: subtotal + tax + processingFee.fee,\n    discounts: {\n      volume: pricingData.volumeDiscount,\n      seasonal: pricingData.seasonalDiscount,\n      total: pricingData.totalDiscount\n    },\n    fees: {\n      processing: processingFee,\n      tax: FINANCIAL_CONSTANTS.TAX_RATE\n    },\n    loyalty: {\n      tier: loyaltyTier.name,\n      benefits: loyaltyTier.benefits\n    },\n    isAnnual,\n    quantity: qty\n  };\n};\n\n/**\r\n * Get business recommendations based on current configuration\r\n * @param {Array} products - Array of selected products\r\n * @param {number} serviceCharge - Service charge amount\r\n * @param {string} billingCycle - Billing cycle (monthly/annual)\r\n * @param {number} profitBeforeTax - Profit before tax\r\n * @param {number} totalSpend - Total customer spend\r\n * @param {number} monthlyVolume - Monthly transaction volume\r\n * @returns {Array} Array of recommendations\r\n */\nexport const getRecommendations = (products, serviceCharge, billingCycle, profitBeforeTax, totalSpend = 0, monthlyVolume = 0) => {\n  if (!Array.isArray(products) || typeof serviceCharge !== 'number' || !['monthly', 'annual'].includes(billingCycle) || typeof profitBeforeTax !== 'number') {\n    throw new Error('Invalid input parameters');\n  }\n  const recommendations = [];\n  const selectedCategories = products.map(p => p.category);\n  const currentSeason = getCurrentSeasonalPricing();\n  const isAnnual = billingCycle === 'annual';\n\n  // Calculate total amount for fee waiver recommendations\n  const totalAmount = products.reduce((sum, p) => {\n    const pricingData = getPricingData(p, p.qty);\n    return sum + pricingData.recommendedPrice * p.qty;\n  }, 0);\n\n  // Loyalty tier recommendations\n  const currentTier = getLoyaltyTier(totalSpend);\n  const nextTier = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS).find(([, tier]) => tier.minSpend > currentTier.minSpend);\n  if (nextTier) {\n    const [, nextTierData] = nextTier;\n    const remainingForNextTier = nextTierData.minSpend - totalSpend;\n    recommendations.push(`Add $${remainingForNextTier.toFixed(2)} more to your total spend to reach ${nextTierData.name} tier and get ${(nextTierData.benefits.processingFeeDiscount * 100).toFixed(0)}% off processing fees.`);\n  }\n\n  // Volume-based fee tier recommendations\n  const currentFeeTier = getProcessingFeeTier(monthlyVolume);\n  const nextFeeTier = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES.find(tier => tier.minVolume > currentFeeTier.minVolume);\n  if (nextFeeTier) {\n    const remainingForNextTier = nextFeeTier.minVolume - monthlyVolume;\n    recommendations.push(`Increase your monthly volume by $${remainingForNextTier.toFixed(2)} to qualify for lower processing fees (${(nextFeeTier.percentageFee * 100).toFixed(2)}% + $${nextFeeTier.baseFee.toFixed(2)}).`);\n  }\n\n  // Payment processing fee recommendations\n  if (!isAnnual && totalAmount < FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER) {\n    const remainingForWaiver = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER - totalAmount;\n    recommendations.push(`Add $${remainingForWaiver.toFixed(2)} more to your order to qualify for automatic payment processing fee waiver.`);\n  }\n  if (!isAnnual && FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.ANNUAL_COMMITMENT_WAIVER) {\n    recommendations.push(\"Switch to annual billing to automatically waive payment processing fees.\");\n  }\n\n  // Add seasonal pricing recommendation\n  if (currentSeason.discount > 0) {\n    recommendations.push(`Take advantage of our ${currentSeason.name} with ${(currentSeason.discount * 100).toFixed(0)}% off!`);\n  }\n\n  // Volume discount recommendations\n  products.forEach(p => {\n    const nextVolumeTier = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS.find(tier => tier.minQty > p.qty);\n    if (nextVolumeTier) {\n      const additionalQty = nextVolumeTier.minQty - p.qty;\n      const potentialDiscount = nextVolumeTier.discount;\n      recommendations.push(`Add ${additionalQty} more ${p.name} units to qualify for ${(potentialDiscount * 100).toFixed(0)}% volume discount.`);\n    }\n  });\n\n  // 1. Margin improvement\n  const lowMarginProducts = products.filter(p => getPricingData(p, p.qty).margin < FINANCIAL_CONSTANTS.TARGET_MARGIN);\n  if (lowMarginProducts.length > 0) {\n    lowMarginProducts.forEach(p => {\n      const currentMargin = getPricingData(p, p.qty).margin;\n      recommendations.push(`Increase the margin for \"${p.name}\" (currently ${(currentMargin * 100).toFixed(1)}%) to at least ${(FINANCIAL_CONSTANTS.TARGET_MARGIN * 100).toFixed(1)}% to improve profitability.`);\n    });\n  }\n\n  // 2. Upsell higher-margin products\n  const highMarginProducts = products.filter(p => getPricingData(p, p.qty).margin >= FINANCIAL_CONSTANTS.HIGH_MARGIN);\n  if (highMarginProducts.length > 0) {\n    highMarginProducts.forEach(p => {\n      const margin = getPricingData(p, p.qty).margin;\n      recommendations.push(`Focus on upselling \"${p.name}\" (margin ${(margin * 100).toFixed(1)}%) for better profit.`);\n    });\n  }\n\n  // 3. Bundle services\n  if (products.length > 1) {\n    const bundleDiscount = FINANCIAL_CONSTANTS.ANNUAL_DISCOUNT_RATE * 100;\n    recommendations.push(`Bundle multiple products/services for a more attractive offer. Consider offering a ${bundleDiscount}% discount for annual commitments.`);\n  }\n\n  // 4. Service charge review\n  if (serviceCharge < FINANCIAL_CONSTANTS.MIN_SERVICE_FEE) {\n    recommendations.push(`Consider increasing your Professional Services & Support fee to at least $${FINANCIAL_CONSTANTS.MIN_SERVICE_FEE}/year to match industry averages.`);\n  }\n\n  // 5. Profitability check\n  if (profitBeforeTax < 0) {\n    recommendations.push(\"Warning: Your current configuration is not profitable. Review your pricing and costs.\");\n  } else if (profitBeforeTax < FINANCIAL_CONSTANTS.MIN_PROFIT_THRESHOLD) {\n    recommendations.push(`Your profit ($${profitBeforeTax.toFixed(2)}) is below the recommended threshold of $${FINANCIAL_CONSTANTS.MIN_PROFIT_THRESHOLD}. Consider increasing margins or service fees, or reducing costs.`);\n  } else {\n    recommendations.push(`Your configuration is profitable ($${profitBeforeTax.toFixed(2)}). Look for further upsell opportunities or cost optimizations.`);\n  }\n\n  // 6. Complementary product recommendations\n  const complementaryCategories = {\n    Desktop: [\"Server\", \"SaaS\"],\n    Server: [\"SaaS\", \"Virtual Server\"],\n    \"Virtual Server\": [\"SaaS\"],\n    SaaS: [\"Server\", \"Virtual Server\"]\n  };\n  const missingCategories = Object.entries(complementaryCategories).filter(([category]) => selectedCategories.includes(category)).flatMap(([, compCategories]) => compCategories.filter(cat => !selectedCategories.includes(cat))).filter((cat, index, self) => self.indexOf(cat) === index);\n  if (missingCategories.length > 0) {\n    const suggestedProduct = products.find(p => missingCategories.includes(p.category));\n    if (suggestedProduct) {\n      const potentialRevenue = formatCurrency(suggestedProduct.pricingSlabs[0].recommendedPrice * 5);\n      const annualRevenue = billingCycle === 'annual' ? formatCurrency(potentialRevenue * 12) : potentialRevenue;\n      recommendations.push(`Enhance your solution by adding a \"${suggestedProduct.category}\" product like \"${suggestedProduct.name}\". ` + `This can provide a more comprehensive backup strategy and increase your revenue by approximately $${annualRevenue} ${billingCycle === 'annual' ? 'per year' : 'per month'} for 5 units.`);\n    }\n  }\n  return recommendations;\n};","map":{"version":3,"names":["FINANCIAL_CONSTANTS","ANNUAL_DISCOUNT_RATE","INDUSTRY_AVG_SERVICE_FEE","SERVICE_FEE_THRESHOLD_LOW","SERVICE_FEE_THRESHOLD_HIGH","TAX_RATE","DEFAULT_MARGIN","MIN_MARGIN","TARGET_MARGIN","HIGH_MARGIN","MIN_PROFIT_THRESHOLD","MIN_SERVICE_FEE","VOLUME_DISCOUNTS","minQty","discount","SEASONAL_PRICING","Q1","name","months","Q2","Q3","Q4","PAYMENT_PROCESSING","BASE_FEE","PERCENTAGE_FEE","MIN_AMOUNT_FOR_WAIVER","ANNUAL_COMMITMENT_WAIVER","TIERED_FEES","minVolume","baseFee","percentageFee","LOYALTY_TIERS","BRONZE","minSpend","benefits","processingFeeDiscount","serviceFeeDiscount","specialPromotions","SILVER","GOLD","prioritySupport","PLATINUM","dedicatedAccountManager","calculateVolumeDiscount","qty","applicableDiscount","filter","tier","sort","a","b","getCurrentSeasonalPricing","currentMonth","Date","getMonth","Object","values","find","period","includes","getPricingData","product","pricingSlabs","Error","Number","isInteger","forEach","slab","unitCost","margin","maxQty","length","volumeDiscount","seasonalPricing","totalDiscount","Math","min","discountedPrice","recommendedPrice","formatCurrency","seasonalDiscount","seasonalPeriod","getPackageName","products","Array","isArray","amount","isNaN","isFinite","round","getLoyaltyTier","totalSpend","tiers","entries","getProcessingFeeTier","monthlyVolume","calculatePaymentProcessingFee","isAnnual","waiveFees","fee","percentage","isWaived","reason","feeTier","totalFee","loyaltyTier","loyaltyDiscount","discountedFee","qualifiesForWaiver","toLocaleString","originalFee","calculateTotalCost","pricingData","subtotal","tax","processingFee","total","discounts","volume","seasonal","fees","processing","loyalty","quantity","getRecommendations","serviceCharge","billingCycle","profitBeforeTax","recommendations","selectedCategories","map","p","category","currentSeason","totalAmount","reduce","sum","currentTier","nextTier","nextTierData","remainingForNextTier","push","toFixed","currentFeeTier","nextFeeTier","remainingForWaiver","nextVolumeTier","additionalQty","potentialDiscount","lowMarginProducts","currentMargin","highMarginProducts","bundleDiscount","complementaryCategories","Desktop","Server","SaaS","missingCategories","flatMap","compCategories","cat","index","self","indexOf","suggestedProduct","potentialRevenue","annualRevenue"],"sources":["C:/Users/Hasan/Desktop/vscode/etcalc/src/utils/pricing.js"],"sourcesContent":["// Constants for financial calculations\r\nexport const FINANCIAL_CONSTANTS = {\r\n  ANNUAL_DISCOUNT_RATE: 0.03,\r\n  INDUSTRY_AVG_SERVICE_FEE: 100,\r\n  SERVICE_FEE_THRESHOLD_LOW: 0.8,\r\n  SERVICE_FEE_THRESHOLD_HIGH: 1.2,\r\n  TAX_RATE: 0.13,\r\n  DEFAULT_MARGIN: 0.35,\r\n  MIN_MARGIN: 0.20,\r\n  TARGET_MARGIN: 0.35,\r\n  HIGH_MARGIN: 0.40,\r\n  MIN_PROFIT_THRESHOLD: 200,\r\n  MIN_SERVICE_FEE: 100,\r\n  // Volume discount tiers\r\n  VOLUME_DISCOUNTS: [\r\n    { minQty: 5, discount: 0.05 },  // 5% off for 5+ units\r\n    { minQty: 10, discount: 0.10 }, // 10% off for 10+ units\r\n    { minQty: 20, discount: 0.15 }, // 15% off for 20+ units\r\n    { minQty: 50, discount: 0.20 }  // 20% off for 50+ units\r\n  ],\r\n  // Seasonal pricing periods\r\n  SEASONAL_PRICING: {\r\n    Q1: { name: \"New Year Special\", discount: 0.10, months: [0, 1, 2] },    // Jan-Mar\r\n    Q2: { name: \"Spring Promotion\", discount: 0.05, months: [3, 4, 5] },    // Apr-Jun\r\n    Q3: { name: \"Summer Sale\", discount: 0.15, months: [6, 7, 8] },         // Jul-Sep\r\n    Q4: { name: \"Year-End Deal\", discount: 0.20, months: [9, 10, 11] }      // Oct-Dec\r\n  },\r\n  // Payment processing fee constants\r\n  PAYMENT_PROCESSING: {\r\n    BASE_FEE: 0.30,\r\n    PERCENTAGE_FEE: 0.0299,\r\n    MIN_AMOUNT_FOR_WAIVER: 1000, // Minimum amount to qualify for fee waiver\r\n    ANNUAL_COMMITMENT_WAIVER: true, // Whether annual commitments qualify for fee waiver\r\n    // Tiered processing fees based on monthly transaction volume\r\n    TIERED_FEES: [\r\n      { minVolume: 0, baseFee: 0.30, percentageFee: 0.0299 },\r\n      { minVolume: 10000, baseFee: 0.25, percentageFee: 0.0275 },\r\n      { minVolume: 50000, baseFee: 0.20, percentageFee: 0.0250 },\r\n      { minVolume: 100000, baseFee: 0.15, percentageFee: 0.0225 },\r\n      { minVolume: 500000, baseFee: 0.10, percentageFee: 0.0200 }\r\n    ]\r\n  },\r\n  // Customer loyalty tiers\r\n  LOYALTY_TIERS: {\r\n    BRONZE: {\r\n      name: \"Bronze\",\r\n      minSpend: 0,\r\n      benefits: {\r\n        processingFeeDiscount: 0,\r\n        serviceFeeDiscount: 0,\r\n        specialPromotions: false\r\n      }\r\n    },\r\n    SILVER: {\r\n      name: \"Silver\",\r\n      minSpend: 5000,\r\n      benefits: {\r\n        processingFeeDiscount: 0.25, // 25% off processing fees\r\n        serviceFeeDiscount: 0.10,    // 10% off service fees\r\n        specialPromotions: true\r\n      }\r\n    },\r\n    GOLD: {\r\n      name: \"Gold\",\r\n      minSpend: 20000,\r\n      benefits: {\r\n        processingFeeDiscount: 0.50, // 50% off processing fees\r\n        serviceFeeDiscount: 0.20,    // 20% off service fees\r\n        specialPromotions: true,\r\n        prioritySupport: true\r\n      }\r\n    },\r\n    PLATINUM: {\r\n      name: \"Platinum\",\r\n      minSpend: 50000,\r\n      benefits: {\r\n        processingFeeDiscount: 1.00, // 100% off processing fees\r\n        serviceFeeDiscount: 0.30,    // 30% off service fees\r\n        specialPromotions: true,\r\n        prioritySupport: true,\r\n        dedicatedAccountManager: true\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Calculate volume discount based on quantity\r\n * @param {number} qty - Quantity\r\n * @returns {number} Discount percentage (0-1)\r\n */\r\nexport const calculateVolumeDiscount = (qty) => {\r\n  const applicableDiscount = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS\r\n    .filter(tier => qty >= tier.minQty)\r\n    .sort((a, b) => b.discount - a.discount)[0];\r\n  \r\n  return applicableDiscount ? applicableDiscount.discount : 0;\r\n};\r\n\r\n/**\r\n * Get current seasonal pricing period\r\n * @returns {Object} Seasonal pricing period info\r\n */\r\nexport const getCurrentSeasonalPricing = () => {\r\n  const currentMonth = new Date().getMonth();\r\n  return Object.values(FINANCIAL_CONSTANTS.SEASONAL_PRICING)\r\n    .find(period => period.months.includes(currentMonth)) || \r\n    { name: \"Standard Pricing\", discount: 0 };\r\n};\r\n\r\n/**\r\n * Get pricing data for a product based on quantity\r\n * @param {Object} product - Product object\r\n * @param {number} qty - Quantity\r\n * @returns {Object} Pricing slab data with discounts applied\r\n * @throws {Error} If product or quantity is invalid\r\n */\r\nexport const getPricingData = (product, qty) => {\r\n  if (!product || !product.pricingSlabs) {\r\n    throw new Error('Invalid product data');\r\n  }\r\n  \r\n  if (!Number.isInteger(qty) || qty < 1) {\r\n    throw new Error('Quantity must be a positive integer');\r\n  }\r\n\r\n  // Validate pricing slabs\r\n  product.pricingSlabs.forEach(slab => {\r\n    if (slab.unitCost < 0) {\r\n      throw new Error(`Invalid unit cost (${slab.unitCost}) for product ${product.name}`);\r\n    }\r\n    if (slab.margin < FINANCIAL_CONSTANTS.MIN_MARGIN) {\r\n      throw new Error(`Margin (${slab.margin}) below minimum threshold for product ${product.name}`);\r\n    }\r\n  });\r\n\r\n  const slab = product.pricingSlabs.find(\r\n    slab => qty >= slab.minQty && qty <= slab.maxQty\r\n  ) || product.pricingSlabs[product.pricingSlabs.length - 1];\r\n\r\n  // Calculate discounts\r\n  const volumeDiscount = calculateVolumeDiscount(qty);\r\n  const seasonalPricing = getCurrentSeasonalPricing();\r\n  const totalDiscount = Math.min(volumeDiscount + seasonalPricing.discount, 0.30); // Cap total discount at 30%\r\n\r\n  // Apply discounts to recommended price\r\n  const discountedPrice = slab.recommendedPrice * (1 - totalDiscount);\r\n\r\n  return {\r\n    ...slab,\r\n    recommendedPrice: formatCurrency(discountedPrice),\r\n    volumeDiscount,\r\n    seasonalDiscount: seasonalPricing.discount,\r\n    totalDiscount,\r\n    seasonalPeriod: seasonalPricing.name\r\n  };\r\n};\r\n\r\n/**\r\n * Get package name based on number of products\r\n * @param {Array} products - Array of products\r\n * @returns {string} Package name\r\n */\r\nexport const getPackageName = (products) => {\r\n  if (!Array.isArray(products)) {\r\n    throw new Error('Invalid products array');\r\n  }\r\n  return products.length >= 2 ? \"Backup Total\" : \"Backup Basic\";\r\n};\r\n\r\n/**\r\n * Calculate total cost with proper decimal handling\r\n * @param {number} amount - Amount to format\r\n * @returns {number} Formatted amount with 2 decimal places\r\n */\r\nexport const formatCurrency = (amount) => {\r\n  if (typeof amount !== 'number' || isNaN(amount)) {\r\n    throw new Error('Invalid amount for currency formatting');\r\n  }\r\n  if (!isFinite(amount)) {\r\n    throw new Error('Amount must be a finite number');\r\n  }\r\n  return Number(Math.round(amount + 'e2') + 'e-2');\r\n};\r\n\r\n/**\r\n * Get customer loyalty tier based on total spend\r\n * @param {number} totalSpend - Total customer spend\r\n * @returns {Object} Loyalty tier details\r\n */\r\nexport const getLoyaltyTier = (totalSpend) => {\r\n  const tiers = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS)\r\n    .sort(([, a], [, b]) => b.minSpend - a.minSpend);\r\n\r\n  for (const [, tier] of tiers) {\r\n    if (totalSpend >= tier.minSpend) {\r\n      return tier;\r\n    }\r\n  }\r\n  return FINANCIAL_CONSTANTS.LOYALTY_TIERS.BRONZE;\r\n};\r\n\r\n/**\r\n * Get tiered processing fee based on monthly volume\r\n * @param {number} monthlyVolume - Monthly transaction volume\r\n * @returns {Object} Fee tier details\r\n */\r\nexport const getProcessingFeeTier = (monthlyVolume) => {\r\n  const tiers = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES\r\n    .sort((a, b) => b.minVolume - a.minVolume);\r\n\r\n  for (const tier of tiers) {\r\n    if (monthlyVolume >= tier.minVolume) {\r\n      return tier;\r\n    }\r\n  }\r\n  return tiers[tiers.length - 1];\r\n};\r\n\r\n/**\r\n * Calculate payment processing fee\r\n * @param {number} amount - Transaction amount\r\n * @param {boolean} isAnnual - Whether this is an annual commitment\r\n * @param {boolean} waiveFees - Whether to waive the fees\r\n * @param {number} monthlyVolume - Monthly transaction volume\r\n * @param {number} totalSpend - Total customer spend\r\n * @returns {Object} Fee details\r\n */\r\nexport const calculatePaymentProcessingFee = (amount, isAnnual, waiveFees, monthlyVolume = 0, totalSpend = 0) => {\r\n  if (waiveFees) {\r\n    return {\r\n      fee: 0,\r\n      percentage: 0,\r\n      baseFee: 0,\r\n      isWaived: true,\r\n      reason: isAnnual ? \"Annual commitment\" : \"Fee waiver applied\"\r\n    };\r\n  }\r\n\r\n  // Get applicable fee tier\r\n  const feeTier = getProcessingFeeTier(monthlyVolume);\r\n  const baseFee = feeTier.baseFee;\r\n  const percentageFee = amount * feeTier.percentageFee;\r\n  const totalFee = baseFee + percentageFee;\r\n\r\n  // Get loyalty tier benefits\r\n  const loyaltyTier = getLoyaltyTier(totalSpend);\r\n  const loyaltyDiscount = loyaltyTier.benefits.processingFeeDiscount;\r\n  const discountedFee = totalFee * (1 - loyaltyDiscount);\r\n\r\n  // Check if amount qualifies for automatic waiver\r\n  const qualifiesForWaiver = amount >= FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER ||\r\n    (isAnnual && FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.ANNUAL_COMMITMENT_WAIVER) ||\r\n    loyaltyTier.name === \"PLATINUM\";\r\n\r\n  return {\r\n    fee: qualifiesForWaiver ? 0 : discountedFee,\r\n    percentage: feeTier.percentageFee,\r\n    baseFee,\r\n    isWaived: qualifiesForWaiver,\r\n    reason: qualifiesForWaiver ? \r\n      (isAnnual ? \"Annual commitment\" : \r\n       loyaltyTier.name === \"PLATINUM\" ? \"Platinum tier benefit\" :\r\n       \"Amount exceeds minimum threshold\") : \r\n      \"Standard processing fee\",\r\n    loyaltyTier: loyaltyTier.name,\r\n    feeTier: `$${feeTier.minVolume.toLocaleString()}+`,\r\n    originalFee: totalFee,\r\n    loyaltyDiscount: loyaltyDiscount * 100\r\n  };\r\n};\r\n\r\n/**\r\n * Calculate total cost with all discounts and fees\r\n * @param {Object} product - Product object\r\n * @param {number} qty - Quantity\r\n * @param {boolean} isAnnual - Whether this is an annual commitment\r\n * @param {boolean} waiveFees - Whether to waive processing fees\r\n * @param {number} monthlyVolume - Monthly transaction volume\r\n * @param {number} totalSpend - Total customer spend\r\n * @returns {Object} Complete pricing details\r\n */\r\nexport const calculateTotalCost = (product, qty, isAnnual, waiveFees, monthlyVolume = 0, totalSpend = 0) => {\r\n  const pricingData = getPricingData(product, qty);\r\n  const subtotal = pricingData.recommendedPrice * qty;\r\n  const tax = subtotal * FINANCIAL_CONSTANTS.TAX_RATE;\r\n  const processingFee = calculatePaymentProcessingFee(subtotal + tax, isAnnual, waiveFees, monthlyVolume, totalSpend);\r\n  const loyaltyTier = getLoyaltyTier(totalSpend);\r\n  \r\n  return {\r\n    subtotal,\r\n    tax,\r\n    processingFee: processingFee.fee,\r\n    total: subtotal + tax + processingFee.fee,\r\n    discounts: {\r\n      volume: pricingData.volumeDiscount,\r\n      seasonal: pricingData.seasonalDiscount,\r\n      total: pricingData.totalDiscount\r\n    },\r\n    fees: {\r\n      processing: processingFee,\r\n      tax: FINANCIAL_CONSTANTS.TAX_RATE\r\n    },\r\n    loyalty: {\r\n      tier: loyaltyTier.name,\r\n      benefits: loyaltyTier.benefits\r\n    },\r\n    isAnnual,\r\n    quantity: qty\r\n  };\r\n};\r\n\r\n/**\r\n * Get business recommendations based on current configuration\r\n * @param {Array} products - Array of selected products\r\n * @param {number} serviceCharge - Service charge amount\r\n * @param {string} billingCycle - Billing cycle (monthly/annual)\r\n * @param {number} profitBeforeTax - Profit before tax\r\n * @param {number} totalSpend - Total customer spend\r\n * @param {number} monthlyVolume - Monthly transaction volume\r\n * @returns {Array} Array of recommendations\r\n */\r\nexport const getRecommendations = (products, serviceCharge, billingCycle, profitBeforeTax, totalSpend = 0, monthlyVolume = 0) => {\r\n  if (!Array.isArray(products) || typeof serviceCharge !== 'number' || \r\n      !['monthly', 'annual'].includes(billingCycle) || typeof profitBeforeTax !== 'number') {\r\n    throw new Error('Invalid input parameters');\r\n  }\r\n\r\n  const recommendations = [];\r\n  const selectedCategories = products.map(p => p.category);\r\n  const currentSeason = getCurrentSeasonalPricing();\r\n  const isAnnual = billingCycle === 'annual';\r\n\r\n  // Calculate total amount for fee waiver recommendations\r\n  const totalAmount = products.reduce((sum, p) => {\r\n    const pricingData = getPricingData(p, p.qty);\r\n    return sum + (pricingData.recommendedPrice * p.qty);\r\n  }, 0);\r\n\r\n  // Loyalty tier recommendations\r\n  const currentTier = getLoyaltyTier(totalSpend);\r\n  const nextTier = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS)\r\n    .find(([, tier]) => tier.minSpend > currentTier.minSpend);\r\n\r\n  if (nextTier) {\r\n    const [, nextTierData] = nextTier;\r\n    const remainingForNextTier = nextTierData.minSpend - totalSpend;\r\n    recommendations.push(\r\n      `Add $${remainingForNextTier.toFixed(2)} more to your total spend to reach ${nextTierData.name} tier and get ${(nextTierData.benefits.processingFeeDiscount * 100).toFixed(0)}% off processing fees.`\r\n    );\r\n  }\r\n\r\n  // Volume-based fee tier recommendations\r\n  const currentFeeTier = getProcessingFeeTier(monthlyVolume);\r\n  const nextFeeTier = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES\r\n    .find(tier => tier.minVolume > currentFeeTier.minVolume);\r\n\r\n  if (nextFeeTier) {\r\n    const remainingForNextTier = nextFeeTier.minVolume - monthlyVolume;\r\n    recommendations.push(\r\n      `Increase your monthly volume by $${remainingForNextTier.toFixed(2)} to qualify for lower processing fees (${(nextFeeTier.percentageFee * 100).toFixed(2)}% + $${nextFeeTier.baseFee.toFixed(2)}).`\r\n    );\r\n  }\r\n\r\n  // Payment processing fee recommendations\r\n  if (!isAnnual && totalAmount < FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER) {\r\n    const remainingForWaiver = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER - totalAmount;\r\n    recommendations.push(\r\n      `Add $${remainingForWaiver.toFixed(2)} more to your order to qualify for automatic payment processing fee waiver.`\r\n    );\r\n  }\r\n\r\n  if (!isAnnual && FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.ANNUAL_COMMITMENT_WAIVER) {\r\n    recommendations.push(\r\n      \"Switch to annual billing to automatically waive payment processing fees.\"\r\n    );\r\n  }\r\n\r\n  // Add seasonal pricing recommendation\r\n  if (currentSeason.discount > 0) {\r\n    recommendations.push(\r\n      `Take advantage of our ${currentSeason.name} with ${(currentSeason.discount * 100).toFixed(0)}% off!`\r\n    );\r\n  }\r\n\r\n  // Volume discount recommendations\r\n  products.forEach(p => {\r\n    const nextVolumeTier = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS\r\n      .find(tier => tier.minQty > p.qty);\r\n    \r\n    if (nextVolumeTier) {\r\n      const additionalQty = nextVolumeTier.minQty - p.qty;\r\n      const potentialDiscount = nextVolumeTier.discount;\r\n      recommendations.push(\r\n        `Add ${additionalQty} more ${p.name} units to qualify for ${(potentialDiscount * 100).toFixed(0)}% volume discount.`\r\n      );\r\n    }\r\n  });\r\n\r\n  // 1. Margin improvement\r\n  const lowMarginProducts = products.filter(p => getPricingData(p, p.qty).margin < FINANCIAL_CONSTANTS.TARGET_MARGIN);\r\n  if (lowMarginProducts.length > 0) {\r\n    lowMarginProducts.forEach(p => {\r\n      const currentMargin = getPricingData(p, p.qty).margin;\r\n      recommendations.push(\r\n        `Increase the margin for \"${p.name}\" (currently ${(currentMargin * 100).toFixed(1)}%) to at least ${(FINANCIAL_CONSTANTS.TARGET_MARGIN * 100).toFixed(1)}% to improve profitability.`\r\n      );\r\n    });\r\n  }\r\n\r\n  // 2. Upsell higher-margin products\r\n  const highMarginProducts = products.filter(p => getPricingData(p, p.qty).margin >= FINANCIAL_CONSTANTS.HIGH_MARGIN);\r\n  if (highMarginProducts.length > 0) {\r\n    highMarginProducts.forEach(p => {\r\n      const margin = getPricingData(p, p.qty).margin;\r\n      recommendations.push(`Focus on upselling \"${p.name}\" (margin ${(margin * 100).toFixed(1)}%) for better profit.`);\r\n    });\r\n  }\r\n\r\n  // 3. Bundle services\r\n  if (products.length > 1) {\r\n    const bundleDiscount = FINANCIAL_CONSTANTS.ANNUAL_DISCOUNT_RATE * 100;\r\n    recommendations.push(\r\n      `Bundle multiple products/services for a more attractive offer. Consider offering a ${bundleDiscount}% discount for annual commitments.`\r\n    );\r\n  }\r\n\r\n  // 4. Service charge review\r\n  if (serviceCharge < FINANCIAL_CONSTANTS.MIN_SERVICE_FEE) {\r\n    recommendations.push(\r\n      `Consider increasing your Professional Services & Support fee to at least $${FINANCIAL_CONSTANTS.MIN_SERVICE_FEE}/year to match industry averages.`\r\n    );\r\n  }\r\n\r\n  // 5. Profitability check\r\n  if (profitBeforeTax < 0) {\r\n    recommendations.push(\"Warning: Your current configuration is not profitable. Review your pricing and costs.\");\r\n  } else if (profitBeforeTax < FINANCIAL_CONSTANTS.MIN_PROFIT_THRESHOLD) {\r\n    recommendations.push(\r\n      `Your profit ($${profitBeforeTax.toFixed(2)}) is below the recommended threshold of $${FINANCIAL_CONSTANTS.MIN_PROFIT_THRESHOLD}. Consider increasing margins or service fees, or reducing costs.`\r\n    );\r\n  } else {\r\n    recommendations.push(\r\n      `Your configuration is profitable ($${profitBeforeTax.toFixed(2)}). Look for further upsell opportunities or cost optimizations.`\r\n    );\r\n  }\r\n\r\n  // 6. Complementary product recommendations\r\n  const complementaryCategories = {\r\n    Desktop: [\"Server\", \"SaaS\"],\r\n    Server: [\"SaaS\", \"Virtual Server\"],\r\n    \"Virtual Server\": [\"SaaS\"],\r\n    SaaS: [\"Server\", \"Virtual Server\"],\r\n  };\r\n\r\n  const missingCategories = Object.entries(complementaryCategories)\r\n    .filter(([category]) => selectedCategories.includes(category))\r\n    .flatMap(([, compCategories]) => \r\n      compCategories.filter(cat => !selectedCategories.includes(cat))\r\n    )\r\n    .filter((cat, index, self) => self.indexOf(cat) === index);\r\n\r\n  if (missingCategories.length > 0) {\r\n    const suggestedProduct = products.find(p => missingCategories.includes(p.category));\r\n    if (suggestedProduct) {\r\n      const potentialRevenue = formatCurrency(suggestedProduct.pricingSlabs[0].recommendedPrice * 5);\r\n      const annualRevenue = billingCycle === 'annual' ? \r\n        formatCurrency(potentialRevenue * 12) : \r\n        potentialRevenue;\r\n      \r\n      recommendations.push(\r\n        `Enhance your solution by adding a \"${suggestedProduct.category}\" product like \"${suggestedProduct.name}\". ` +\r\n        `This can provide a more comprehensive backup strategy and increase your revenue by approximately $${annualRevenue} ${billingCycle === 'annual' ? 'per year' : 'per month'} for 5 units.`\r\n      );\r\n    }\r\n  }\r\n\r\n  return recommendations;\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}