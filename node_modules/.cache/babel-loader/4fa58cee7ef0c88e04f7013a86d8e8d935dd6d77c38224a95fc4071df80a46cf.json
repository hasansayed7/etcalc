{"ast":null,"code":"/**\n * @typedef {Object} Product\n * @property {string} name\n * @property {string} description\n * @property {string} license\n * @property {string} [category]\n * @property {Array<{minQty: number, maxQty: number, unitCost: number, margin?: number, recommendedPrice: number}>} pricingSlabs\n * @property {number} [unitCost]\n * @property {number} [margin]\n * @property {boolean} [isHomeGrown]\n * @property {number} [qty]\n */\n\n// Constants for financial calculations\nexport const FINANCIAL_CONSTANTS = {\n  ANNUAL_DISCOUNT_RATE: 0.03,\n  INDUSTRY_AVG_SERVICE_FEE: 100,\n  SERVICE_FEE_THRESHOLD_LOW: 0.8,\n  SERVICE_FEE_THRESHOLD_HIGH: 1.2,\n  TAX_RATE: 0.13,\n  DEFAULT_MARGIN: 0.35,\n  MIN_MARGIN: 0.20,\n  TARGET_MARGIN: 0.35,\n  HIGH_MARGIN: 0.40,\n  MIN_PROFIT_THRESHOLD: 200,\n  MIN_SERVICE_FEE: 100,\n  // Volume discount tiers\n  VOLUME_DISCOUNTS: [{\n    minQty: 5,\n    discount: 0.05\n  },\n  // 5% off for 5+ units\n  {\n    minQty: 10,\n    discount: 0.10\n  },\n  // 10% off for 10+ units\n  {\n    minQty: 20,\n    discount: 0.15\n  },\n  // 15% off for 20+ units\n  {\n    minQty: 50,\n    discount: 0.20\n  } // 20% off for 50+ units\n  ],\n  // Seasonal pricing periods\n  SEASONAL_PRICING: {\n    Q1: {\n      name: \"New Year Special\",\n      discount: 0.10,\n      months: [0, 1, 2]\n    },\n    // Jan-Mar\n    Q2: {\n      name: \"Spring Promotion\",\n      discount: 0.05,\n      months: [3, 4, 5]\n    },\n    // Apr-Jun\n    Q3: {\n      name: \"Summer Sale\",\n      discount: 0.15,\n      months: [6, 7, 8]\n    },\n    // Jul-Sep\n    Q4: {\n      name: \"Year-End Deal\",\n      discount: 0.20,\n      months: [9, 10, 11]\n    } // Oct-Dec\n  },\n  // Payment processing fee constants\n  PAYMENT_PROCESSING: {\n    BASE_FEE: 0.30,\n    PERCENTAGE_FEE: 0.0299,\n    MIN_AMOUNT_FOR_WAIVER: 1000,\n    // Minimum amount to qualify for fee waiver\n    ANNUAL_COMMITMENT_WAIVER: true,\n    // Whether annual commitments qualify for fee waiver\n    // Tiered processing fees based on monthly transaction volume\n    TIERED_FEES: [{\n      minVolume: 0,\n      baseFee: 0.30,\n      percentageFee: 0.0299\n    }, {\n      minVolume: 10000,\n      baseFee: 0.25,\n      percentageFee: 0.0275\n    }, {\n      minVolume: 50000,\n      baseFee: 0.20,\n      percentageFee: 0.0250\n    }, {\n      minVolume: 100000,\n      baseFee: 0.15,\n      percentageFee: 0.0225\n    }, {\n      minVolume: 500000,\n      baseFee: 0.10,\n      percentageFee: 0.0200\n    }]\n  },\n  // Customer loyalty tiers\n  LOYALTY_TIERS: {\n    BRONZE: {\n      name: \"Bronze\",\n      minSpend: 0,\n      benefits: {\n        processingFeeDiscount: 0,\n        serviceFeeDiscount: 0,\n        specialPromotions: false\n      }\n    },\n    SILVER: {\n      name: \"Silver\",\n      minSpend: 5000,\n      benefits: {\n        processingFeeDiscount: 0.25,\n        // 25% off processing fees\n        serviceFeeDiscount: 0.10,\n        // 10% off service fees\n        specialPromotions: true\n      }\n    },\n    GOLD: {\n      name: \"Gold\",\n      minSpend: 20000,\n      benefits: {\n        processingFeeDiscount: 0.50,\n        // 50% off processing fees\n        serviceFeeDiscount: 0.20,\n        // 20% off service fees\n        specialPromotions: true,\n        prioritySupport: true\n      }\n    },\n    PLATINUM: {\n      name: \"Platinum\",\n      minSpend: 50000,\n      benefits: {\n        processingFeeDiscount: 1.00,\n        // 100% off processing fees\n        serviceFeeDiscount: 0.30,\n        // 30% off service fees\n        specialPromotions: true,\n        prioritySupport: true,\n        dedicatedAccountManager: true\n      }\n    }\n  },\n  // Enhanced commitment levels\n  COMMITMENT_LEVELS: {\n    MONTHLY: {\n      name: \"Monthly\",\n      discount: 0,\n      minTerm: 1,\n      cancellationFee: 0,\n      features: [\"Basic Support\", \"Standard Features\"]\n    },\n    QUARTERLY: {\n      name: \"Quarterly\",\n      discount: 0.05,\n      minTerm: 3,\n      cancellationFee: 0.1,\n      features: [\"Priority Support\", \"Advanced Features\", \"Monthly Reports\"]\n    },\n    BIANNUAL: {\n      name: \"Bi-Annual\",\n      discount: 0.10,\n      minTerm: 6,\n      cancellationFee: 0.15,\n      features: [\"Premium Support\", \"Enterprise Features\", \"Quarterly Reviews\"]\n    },\n    ANNUAL: {\n      name: \"Annual\",\n      discount: 0.15,\n      minTerm: 12,\n      cancellationFee: 0.2,\n      features: [\"24/7 Support\", \"All Features\", \"Quarterly Reviews\", \"Dedicated Account Manager\"]\n    }\n  },\n  // Enhanced upsell opportunities\n  UPSELL_OPPORTUNITIES: {\n    PREMIUM_SUPPORT: {\n      name: \"Premium Support\",\n      basePrice: 199,\n      margin: 0.75,\n      minCommitment: \"QUARTERLY\",\n      features: [\"24/7 Priority Support\", \"Dedicated Account Manager\", \"Custom Integration Support\", \"Advanced Analytics\"]\n    },\n    ENTERPRISE_FEATURES: {\n      name: \"Enterprise Features\",\n      basePrice: 299,\n      margin: 0.80,\n      minCommitment: \"BIANNUAL\",\n      features: [\"Custom Workflows\", \"API Access\", \"Advanced Security\", \"Multi-region Support\"]\n    },\n    TRAINING_PACKAGE: {\n      name: \"Training Package\",\n      basePrice: 499,\n      margin: 0.85,\n      minCommitment: \"QUARTERLY\",\n      features: [\"On-site Training\", \"Custom Documentation\", \"Best Practices Guide\", \"Ongoing Support\"]\n    },\n    CUSTOM_INTEGRATION: {\n      name: \"Custom Integration\",\n      basePrice: 999,\n      margin: 0.90,\n      minCommitment: \"ANNUAL\",\n      features: [\"Custom API Development\", \"Integration Testing\", \"Performance Optimization\", \"Ongoing Maintenance\"]\n    },\n    DEDICATED_SERVER: {\n      name: \"Dedicated Server\",\n      basePrice: 799,\n      margin: 0.85,\n      minCommitment: \"ANNUAL\",\n      features: [\"Dedicated Hardware\", \"Custom Configuration\", \"24/7 Monitoring\", \"Backup Solutions\"]\n    },\n    SECURITY_PACKAGE: {\n      name: \"Security Package\",\n      basePrice: 399,\n      margin: 0.80,\n      minCommitment: \"QUARTERLY\",\n      features: [\"Advanced Encryption\", \"Security Auditing\", \"Compliance Support\", \"Regular Security Updates\"]\n    }\n  },\n  // Dynamic pricing factors\n  DYNAMIC_PRICING: {\n    TIME_BASED: {\n      PEAK_HOURS: {\n        multiplier: 1.1,\n        hours: [9, 10, 11, 14, 15, 16]\n      },\n      OFF_PEAK: {\n        multiplier: 0.9,\n        hours: [0, 1, 2, 3, 4, 5, 6, 7, 8, 20, 21, 22, 23]\n      }\n    },\n    DEMAND_BASED: {\n      HIGH: {\n        threshold: 0.8,\n        multiplier: 1.15\n      },\n      MEDIUM: {\n        threshold: 0.5,\n        multiplier: 1.0\n      },\n      LOW: {\n        threshold: 0.2,\n        multiplier: 0.85\n      }\n    },\n    CUSTOMER_BASED: {\n      NEW: {\n        multiplier: 1.0\n      },\n      RETURNING: {\n        multiplier: 0.95\n      },\n      LOYAL: {\n        multiplier: 0.90\n      }\n    }\n  },\n  // Enhanced profit optimization\n  PROFIT_OPTIMIZATION: {\n    MIN_MARGIN: 0.30,\n    TARGET_MARGIN: 0.40,\n    HIGH_MARGIN: 0.50,\n    MIN_COMMITMENT_DISCOUNT: 0.05,\n    MAX_COMMITMENT_DISCOUNT: 0.20,\n    BUNDLE_DISCOUNT: 0.10,\n    REFERRAL_BONUS: 0.05,\n    CROSS_SELL_THRESHOLD: 0.15,\n    UPSELL_THRESHOLD: 0.25,\n    RETENTION_BONUS: 0.10,\n    EARLY_RENEWAL_DISCOUNT: 0.08,\n    BULK_PURCHASE_THRESHOLD: 10,\n    BULK_PURCHASE_DISCOUNT: 0.15\n  }\n};\n\n/**\n * Calculate volume discount based on quantity\n * @param {number} qty - Quantity\n * @returns {number} Discount percentage (0-1)\n */\nexport const calculateVolumeDiscount = qty => {\n  const applicableDiscount = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS.filter(tier => qty >= tier.minQty).sort((a, b) => b.discount - a.discount)[0];\n  return applicableDiscount ? applicableDiscount.discount : 0;\n};\n\n/**\n * Get current seasonal pricing period\n * @returns {Object} Seasonal pricing period info\n */\nexport const getCurrentSeasonalPricing = () => {\n  const currentMonth = new Date().getMonth();\n  return Object.values(FINANCIAL_CONSTANTS.SEASONAL_PRICING).find(period => period.months.includes(currentMonth)) || {\n    name: \"Standard Pricing\",\n    discount: 0\n  };\n};\n\n/**\n * Get pricing data for a product based on quantity\n * @param {Object} product - Product object\n * @param {number} qty - Quantity\n * @returns {Object} Pricing slab data with discounts applied\n * @throws {Error} If product or quantity is invalid\n */\nexport const getPricingData = (product, qty) => {\n  if (!product || !product.pricingSlabs) {\n    throw new Error('Invalid product data');\n  }\n  if (!Number.isInteger(qty) || qty < 1) {\n    throw new Error('Quantity must be a positive integer');\n  }\n\n  // Validate pricing slabs\n  product.pricingSlabs.forEach(slab => {\n    if (slab.unitCost < 0) {\n      throw new Error(`Invalid unit cost (${slab.unitCost}) for product ${product.name}`);\n    }\n    // Only enforce margin for non-homegrown products\n    if (!product.isHomeGrown && slab.margin < FINANCIAL_CONSTANTS.MIN_MARGIN) {\n      throw new Error(`Margin (${slab.margin}) below minimum threshold for product ${product.name}`);\n    }\n  });\n  const slab = product.pricingSlabs.find(slab => qty >= slab.minQty && qty <= slab.maxQty) || product.pricingSlabs[product.pricingSlabs.length - 1];\n\n  // For home-grown products, recommendedPrice = unitCost * 1.13\n  let recommendedPrice = slab.recommendedPrice;\n  if (product.isHomeGrown) {\n    recommendedPrice = slab.unitCost * 1.13;\n  }\n\n  // Calculate discounts\n  const volumeDiscount = calculateVolumeDiscount(qty);\n  const seasonalPricing = getCurrentSeasonalPricing();\n  const totalDiscount = Math.min(volumeDiscount + seasonalPricing.discount, 0.30); // Cap total discount at 30%\n\n  // Apply discounts to recommended price\n  const discountedPrice = recommendedPrice * (1 - totalDiscount);\n  return {\n    ...slab,\n    recommendedPrice: formatCurrency(discountedPrice),\n    volumeDiscount,\n    seasonalDiscount: seasonalPricing.discount,\n    totalDiscount,\n    seasonalPeriod: seasonalPricing.name\n  };\n};\n\n/**\n * Get package name based on number of products\n * @param {Array} products - Array of products\n * @returns {string} Package name\n */\nexport const getPackageName = products => {\n  if (!Array.isArray(products)) {\n    throw new Error('Invalid products array');\n  }\n  return products.length >= 2 ? \"Backup Total\" : \"Backup Basic\";\n};\n\n/**\n * Calculate total cost with proper decimal handling\n * @param {number} amount - Amount to format\n * @returns {number} Formatted amount with 2 decimal places\n */\nexport const formatCurrency = amount => {\n  if (typeof amount !== 'number' || isNaN(amount)) {\n    throw new Error('Invalid amount for currency formatting');\n  }\n  if (!isFinite(amount)) {\n    throw new Error('Amount must be a finite number');\n  }\n  return Number(Math.round(amount + 'e2') + 'e-2');\n};\n\n/**\n * Get customer loyalty tier based on total spend\n * @param {number} totalSpend - Total customer spend\n * @returns {Object} Loyalty tier details\n */\nexport const getLoyaltyTier = totalSpend => {\n  const tiers = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS).sort(([, a], [, b]) => b.minSpend - a.minSpend);\n  for (const [, tier] of tiers) {\n    if (totalSpend >= tier.minSpend) {\n      return tier;\n    }\n  }\n  return FINANCIAL_CONSTANTS.LOYALTY_TIERS.BRONZE;\n};\n\n/**\n * Get tiered processing fee based on monthly volume\n * @param {number} monthlyVolume - Monthly transaction volume\n * @returns {Object} Fee tier details\n */\nexport const getProcessingFeeTier = monthlyVolume => {\n  const tiers = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES.sort((a, b) => b.minVolume - a.minVolume);\n  for (const tier of tiers) {\n    if (monthlyVolume >= tier.minVolume) {\n      return tier;\n    }\n  }\n  return tiers[tiers.length - 1];\n};\n\n/**\n * Calculate payment processing fee\n * @param {number} amount - Transaction amount\n * @param {boolean} isAnnual - Whether this is an annual commitment\n * @param {boolean} waiveFees - Whether to waive the fees\n * @param {number} monthlyVolume - Monthly transaction volume\n * @param {number} totalSpend - Total customer spend\n * @returns {Object} Fee details\n */\nexport const calculatePaymentProcessingFee = (amount, isAnnual, waiveFees, monthlyVolume = 0, totalSpend = 0) => {\n  if (waiveFees) {\n    return {\n      fee: 0,\n      percentage: 0,\n      baseFee: 0,\n      isWaived: true,\n      reason: isAnnual ? \"Annual commitment\" : \"Fee waiver applied\"\n    };\n  }\n\n  // Get applicable fee tier\n  const feeTier = getProcessingFeeTier(monthlyVolume);\n  const baseFee = feeTier.baseFee;\n  const percentageFee = amount * feeTier.percentageFee;\n  const totalFee = baseFee + percentageFee;\n\n  // Get loyalty tier benefits\n  const loyaltyTier = getLoyaltyTier(totalSpend);\n  const loyaltyDiscount = loyaltyTier.benefits.processingFeeDiscount;\n  const discountedFee = totalFee * (1 - loyaltyDiscount);\n\n  // Check if amount qualifies for automatic waiver\n  const qualifiesForWaiver = amount >= FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER || isAnnual && FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.ANNUAL_COMMITMENT_WAIVER || loyaltyTier.name === \"PLATINUM\";\n  return {\n    fee: qualifiesForWaiver ? 0 : discountedFee,\n    percentage: feeTier.percentageFee,\n    baseFee,\n    isWaived: qualifiesForWaiver,\n    reason: qualifiesForWaiver ? isAnnual ? \"Annual commitment\" : loyaltyTier.name === \"PLATINUM\" ? \"Platinum tier benefit\" : \"Amount exceeds minimum threshold\" : \"Standard processing fee\",\n    loyaltyTier: loyaltyTier.name,\n    feeTier: `$${feeTier.minVolume.toLocaleString()}+`,\n    originalFee: totalFee,\n    loyaltyDiscount: loyaltyDiscount * 100\n  };\n};\n\n/**\n * Calculate fee savings analytics\n * @param {Object} feeDetails - Fee calculation details\n * @param {number} monthlyVolume - Monthly transaction volume\n * @param {number} totalSpend - Total customer spend\n * @returns {Object} Fee savings analytics\n */\nexport const calculateFeeSavings = (feeDetails, monthlyVolume, totalSpend) => {\n  var _loyaltySavings$next, _volumeSavings$next, _loyaltySavings$next2, _volumeSavings$next2, _loyaltySavings$next3, _volumeSavings$next3;\n  const currentTier = getLoyaltyTier(totalSpend);\n  const currentFeeTier = getProcessingFeeTier(monthlyVolume);\n\n  // Calculate potential savings from next loyalty tier\n  const nextLoyaltyTier = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS).find(([, tier]) => tier.minSpend > currentTier.minSpend);\n  let loyaltySavings = {\n    current: {\n      tier: currentTier.name,\n      discount: currentTier.benefits.processingFeeDiscount * 100,\n      monthlySavings: feeDetails.originalFee * currentTier.benefits.processingFeeDiscount,\n      annualSavings: feeDetails.originalFee * currentTier.benefits.processingFeeDiscount * 12\n    },\n    next: null\n  };\n  if (nextLoyaltyTier) {\n    const [, nextTierData] = nextLoyaltyTier;\n    const nextTierDiscount = nextTierData.benefits.processingFeeDiscount;\n    const potentialMonthlySavings = feeDetails.originalFee * nextTierDiscount;\n    const currentMonthlySavings = feeDetails.originalFee * currentTier.benefits.processingFeeDiscount;\n    loyaltySavings.next = {\n      tier: nextTierData.name,\n      discount: nextTierDiscount * 100,\n      additionalMonthlySavings: potentialMonthlySavings - currentMonthlySavings,\n      additionalAnnualSavings: (potentialMonthlySavings - currentMonthlySavings) * 12,\n      requiredSpend: nextTierData.minSpend - totalSpend\n    };\n  }\n\n  // Calculate potential savings from next fee tier\n  const nextFeeTier = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES.find(tier => tier.minVolume > currentFeeTier.minVolume);\n  let volumeSavings = {\n    current: {\n      tier: `$${currentFeeTier.minVolume.toLocaleString()}+`,\n      rate: currentFeeTier.percentageFee * 100,\n      baseFee: currentFeeTier.baseFee,\n      monthlyFees: feeDetails.originalFee,\n      annualFees: feeDetails.originalFee * 12\n    },\n    next: null\n  };\n  if (nextFeeTier) {\n    const potentialBaseFee = nextFeeTier.baseFee;\n    const potentialPercentageFee = monthlyVolume * nextFeeTier.percentageFee;\n    const potentialMonthlyFees = potentialBaseFee + potentialPercentageFee;\n    const currentMonthlyFees = feeDetails.originalFee;\n    volumeSavings.next = {\n      tier: `$${nextFeeTier.minVolume.toLocaleString()}+`,\n      rate: nextFeeTier.percentageFee * 100,\n      baseFee: nextFeeTier.baseFee,\n      potentialMonthlyFees,\n      potentialAnnualFees: potentialMonthlyFees * 12,\n      monthlySavings: currentMonthlyFees - potentialMonthlyFees,\n      annualSavings: (currentMonthlyFees - potentialMonthlyFees) * 12,\n      requiredVolume: nextFeeTier.minVolume - monthlyVolume\n    };\n  }\n\n  // Calculate total savings\n  const totalSavings = {\n    current: {\n      monthly: loyaltySavings.current.monthlySavings,\n      annual: loyaltySavings.current.annualSavings,\n      percentage: loyaltySavings.current.monthlySavings / feeDetails.originalFee * 100\n    },\n    potential: {\n      monthly: (((_loyaltySavings$next = loyaltySavings.next) === null || _loyaltySavings$next === void 0 ? void 0 : _loyaltySavings$next.additionalMonthlySavings) || 0) + (((_volumeSavings$next = volumeSavings.next) === null || _volumeSavings$next === void 0 ? void 0 : _volumeSavings$next.monthlySavings) || 0),\n      annual: (((_loyaltySavings$next2 = loyaltySavings.next) === null || _loyaltySavings$next2 === void 0 ? void 0 : _loyaltySavings$next2.additionalAnnualSavings) || 0) + (((_volumeSavings$next2 = volumeSavings.next) === null || _volumeSavings$next2 === void 0 ? void 0 : _volumeSavings$next2.annualSavings) || 0),\n      percentage: ((((_loyaltySavings$next3 = loyaltySavings.next) === null || _loyaltySavings$next3 === void 0 ? void 0 : _loyaltySavings$next3.additionalMonthlySavings) || 0) + (((_volumeSavings$next3 = volumeSavings.next) === null || _volumeSavings$next3 === void 0 ? void 0 : _volumeSavings$next3.monthlySavings) || 0)) / feeDetails.originalFee * 100\n    }\n  };\n  return {\n    loyaltySavings,\n    volumeSavings,\n    totalSavings,\n    recommendations: generateSavingsRecommendations(loyaltySavings, volumeSavings)\n  };\n};\n\n/**\n * Generate savings recommendations\n * @param {Object} loyaltySavings - Loyalty tier savings details\n * @param {Object} volumeSavings - Volume tier savings details\n * @returns {Array} Array of savings recommendations\n */\nconst generateSavingsRecommendations = (loyaltySavings, volumeSavings) => {\n  const recommendations = [];\n  if (loyaltySavings.next) {\n    recommendations.push({\n      type: 'loyalty',\n      message: `Upgrade to ${loyaltySavings.next.tier} tier by spending $${loyaltySavings.next.requiredSpend.toFixed(2)} more to save an additional $${loyaltySavings.next.additionalMonthlySavings.toFixed(2)}/month on processing fees.`,\n      potentialSavings: {\n        monthly: loyaltySavings.next.additionalMonthlySavings,\n        annual: loyaltySavings.next.additionalAnnualSavings\n      }\n    });\n  }\n  if (volumeSavings.next) {\n    recommendations.push({\n      type: 'volume',\n      message: `Increase monthly volume by $${volumeSavings.next.requiredVolume.toFixed(2)} to qualify for the ${volumeSavings.next.tier} tier and save $${volumeSavings.next.monthlySavings.toFixed(2)}/month on processing fees.`,\n      potentialSavings: {\n        monthly: volumeSavings.next.monthlySavings,\n        annual: volumeSavings.next.annualSavings\n      }\n    });\n  }\n  return recommendations;\n};\n\n/**\n * Generate detailed fee report\n * @param {Object} feeDetails - Fee calculation details\n * @param {number} monthlyVolume - Monthly transaction volume\n * @param {number} totalSpend - Total customer spend\n * @returns {Object} Detailed fee report\n */\nexport const generateFeeReport = (feeDetails, monthlyVolume, totalSpend) => {\n  const savings = calculateFeeSavings(feeDetails, monthlyVolume, totalSpend);\n  return {\n    currentFees: {\n      baseFee: feeDetails.baseFee,\n      percentageFee: feeDetails.percentage * 100,\n      totalFee: feeDetails.fee,\n      isWaived: feeDetails.isWaived,\n      waiverReason: feeDetails.reason\n    },\n    currentSavings: {\n      loyaltyTier: savings.loyaltySavings.current.tier,\n      loyaltyDiscount: savings.loyaltySavings.current.discount,\n      monthlySavings: savings.loyaltySavings.current.monthlySavings,\n      annualSavings: savings.loyaltySavings.current.annualSavings\n    },\n    potentialSavings: {\n      loyaltyUpgrade: savings.loyaltySavings.next ? {\n        tier: savings.loyaltySavings.next.tier,\n        additionalDiscount: savings.loyaltySavings.next.discount - savings.loyaltySavings.current.discount,\n        monthlySavings: savings.loyaltySavings.next.additionalMonthlySavings,\n        annualSavings: savings.loyaltySavings.next.additionalAnnualSavings,\n        requiredSpend: savings.loyaltySavings.next.requiredSpend\n      } : null,\n      volumeUpgrade: savings.volumeSavings.next ? {\n        tier: savings.volumeSavings.next.tier,\n        newRate: savings.volumeSavings.next.rate,\n        newBaseFee: savings.volumeSavings.next.baseFee,\n        monthlySavings: savings.volumeSavings.next.monthlySavings,\n        annualSavings: savings.volumeSavings.next.annualSavings,\n        requiredVolume: savings.volumeSavings.next.requiredVolume\n      } : null\n    },\n    totalSavings: {\n      current: {\n        monthly: savings.totalSavings.current.monthly,\n        annual: savings.totalSavings.current.annual,\n        percentage: savings.totalSavings.current.percentage\n      },\n      potential: {\n        monthly: savings.totalSavings.potential.monthly,\n        annual: savings.totalSavings.potential.annual,\n        percentage: savings.totalSavings.potential.percentage\n      }\n    },\n    recommendations: savings.recommendations\n  };\n};\n\n/**\n * Calculate commitment-based pricing\n * @param {number} basePrice - Base price of the product\n * @param {string} commitmentLevel - Commitment level (MONTHLY, QUARTERLY, etc.)\n * @param {number} quantity - Number of units\n * @returns {Object} Commitment pricing details\n */\nexport const calculateCommitmentPricing = (basePrice, commitmentLevel, quantity) => {\n  const commitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel];\n  if (!commitment) {\n    throw new Error('Invalid commitment level');\n  }\n  const discount = commitment.discount;\n  const discountedPrice = basePrice * (1 - discount);\n  const totalPrice = discountedPrice * quantity;\n  const savings = basePrice * quantity - totalPrice;\n  return {\n    commitmentLevel: commitment.name,\n    basePrice,\n    discountedPrice,\n    quantity,\n    totalPrice,\n    savings,\n    discount: discount * 100,\n    minTerm: commitment.minTerm,\n    cancellationFee: commitment.cancellationFee * 100\n  };\n};\n\n/**\n * Get available upsell opportunities\n * @param {Array} currentProducts - Current product selection\n * @param {string} commitmentLevel - Current commitment level\n * @param {number} totalSpend - Total customer spend\n * @returns {Array} Available upsell opportunities\n */\nexport const getUpsellOpportunities = (currentProducts, commitmentLevel, totalSpend) => {\n  const opportunities = [];\n  const currentFeatures = new Set(currentProducts.flatMap(p => p.features || []));\n  Object.entries(FINANCIAL_CONSTANTS.UPSELL_OPPORTUNITIES).forEach(([key, opportunity]) => {\n    // Check if customer qualifies for this upsell\n    const commitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[opportunity.minCommitment];\n    const qualifies = commitment && FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel].minTerm >= commitment.minTerm;\n    if (qualifies) {\n      const newFeatures = opportunity.features.filter(f => !currentFeatures.has(f));\n      if (newFeatures.length > 0) {\n        opportunities.push({\n          ...opportunity,\n          key,\n          newFeatures,\n          price: calculateCommitmentPricing(opportunity.basePrice, commitmentLevel, 1),\n          potentialRevenue: opportunity.basePrice * (1 - FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel].discount),\n          margin: opportunity.margin * 100\n        });\n      }\n    }\n  });\n  return opportunities;\n};\n\n/**\n * Calculate dynamic pricing based on various factors\n * @param {number} basePrice - Base price of the product\n * @param {Object} factors - Pricing factors\n * @returns {number} Adjusted price\n */\nexport const calculateDynamicPricing = (basePrice, factors = {}) => {\n  let adjustedPrice = basePrice;\n  const currentHour = new Date().getHours();\n\n  // Time-based pricing\n  if (FINANCIAL_CONSTANTS.DYNAMIC_PRICING.TIME_BASED.PEAK_HOURS.hours.includes(currentHour)) {\n    adjustedPrice *= FINANCIAL_CONSTANTS.DYNAMIC_PRICING.TIME_BASED.PEAK_HOURS.multiplier;\n  } else if (FINANCIAL_CONSTANTS.DYNAMIC_PRICING.TIME_BASED.OFF_PEAK.hours.includes(currentHour)) {\n    adjustedPrice *= FINANCIAL_CONSTANTS.DYNAMIC_PRICING.TIME_BASED.OFF_PEAK.multiplier;\n  }\n\n  // Demand-based pricing\n  if (factors.demandLevel) {\n    const demandFactor = FINANCIAL_CONSTANTS.DYNAMIC_PRICING.DEMAND_BASED[factors.demandLevel];\n    if (demandFactor) {\n      adjustedPrice *= demandFactor.multiplier;\n    }\n  }\n\n  // Customer-based pricing\n  if (factors.customerType) {\n    const customerFactor = FINANCIAL_CONSTANTS.DYNAMIC_PRICING.CUSTOMER_BASED[factors.customerType];\n    if (customerFactor) {\n      adjustedPrice *= customerFactor.multiplier;\n    }\n  }\n  return formatCurrency(adjustedPrice);\n};\n\n/**\n * Generate email subject with customer name\n * @param {string} customerName - Customer's name\n * @param {string} commitmentLevel - Commitment level\n * @returns {string} Formatted email subject\n */\nexport const generateEmailSubject = (customerName, commitmentLevel) => {\n  const quoteNumber = `QT${new Date().getFullYear()}${String(Math.floor(1000 + Math.random() * 9000)).padStart(4, '0')}`;\n  const commitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel];\n  const commitmentName = commitment ? commitment.name : 'Standard';\n  const date = new Date().toLocaleDateString('en-US', {\n    month: 'short',\n    day: 'numeric',\n    year: 'numeric'\n  });\n  return `[${quoteNumber}] ExcelyTech Quote - ${customerName || \"Customer\"} | ${commitmentName} Plan | ${date}`;\n};\n\n/**\n * Calculate optimal pricing strategy with enhanced features\n * @param {Object} product - Product details\n * @param {number} quantity - Current quantity\n * @param {string} commitmentLevel - Current commitment level\n * @param {number} totalSpend - Total customer spend\n * @param {Object} factors - Dynamic pricing factors\n * @returns {Object} Optimal pricing strategy\n */\nexport const calculateOptimalPricing = (product, quantity, commitmentLevel, totalSpend, factors = {}) => {\n  const currentMargin = getPricingData(product, quantity).margin;\n  const loyaltyTier = getLoyaltyTier(totalSpend);\n  const commitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel];\n\n  // Calculate dynamic base price\n  const dynamicBasePrice = calculateDynamicPricing(product.pricingSlabs[0].recommendedPrice, factors);\n  const strategies = {\n    quantity: {\n      current: quantity,\n      recommended: quantity,\n      potential: 0\n    },\n    commitment: {\n      current: commitmentLevel,\n      recommended: commitmentLevel,\n      potential: 0\n    },\n    upsells: [],\n    crossSells: [],\n    totalPotential: 0\n  };\n\n  // Enhanced quantity optimization\n  if (currentMargin < FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.TARGET_MARGIN) {\n    const nextVolumeTier = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS.find(tier => tier.minQty > quantity);\n    if (nextVolumeTier) {\n      strategies.quantity.recommended = nextVolumeTier.minQty;\n      strategies.quantity.potential = (nextVolumeTier.minQty - quantity) * dynamicBasePrice;\n\n      // Add bulk purchase discount if applicable\n      if (nextVolumeTier.minQty >= FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.BULK_PURCHASE_THRESHOLD) {\n        strategies.quantity.bulkDiscount = FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.BULK_PURCHASE_DISCOUNT * 100;\n      }\n    }\n  }\n\n  // Enhanced commitment optimization\n  const nextCommitment = Object.entries(FINANCIAL_CONSTANTS.COMMITMENT_LEVELS).find(([key, level]) => level.minTerm > commitment.minTerm);\n  if (nextCommitment) {\n    const [nextLevel, nextCommitmentData] = nextCommitment;\n    strategies.commitment.recommended = nextLevel;\n    strategies.commitment.potential = dynamicBasePrice * quantity * (nextCommitmentData.discount - commitment.discount);\n    strategies.commitment.additionalFeatures = nextCommitmentData.features.filter(f => !commitment.features.includes(f));\n  }\n\n  // Enhanced upsell opportunities\n  strategies.upsells = getUpsellOpportunities([product], commitmentLevel, totalSpend).map(upsell => ({\n    name: upsell.name,\n    potential: upsell.potentialRevenue,\n    margin: upsell.margin,\n    features: upsell.newFeatures,\n    dynamicPrice: calculateDynamicPricing(upsell.basePrice, factors)\n  }));\n\n  // Cross-sell opportunities\n  if (currentMargin >= FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.CROSS_SELL_THRESHOLD) {\n    strategies.crossSells = Object.entries(FINANCIAL_CONSTANTS.UPSELL_OPPORTUNITIES).filter(([key, opp]) => opp.margin >= FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.UPSELL_THRESHOLD).map(([key, opp]) => ({\n      name: opp.name,\n      potential: opp.basePrice * (1 - commitment.discount),\n      margin: opp.margin,\n      features: opp.features,\n      dynamicPrice: calculateDynamicPricing(opp.basePrice, factors)\n    }));\n  }\n\n  // Calculate total potential\n  strategies.totalPotential = strategies.quantity.potential + strategies.commitment.potential + strategies.upsells.reduce((sum, upsell) => sum + upsell.potential, 0) + strategies.crossSells.reduce((sum, crossSell) => sum + crossSell.potential, 0);\n  return strategies;\n};\n\n/**\n * Generate profit optimization recommendations\n * @param {Array} products - Current product selection\n * @param {string} commitmentLevel - Current commitment level\n * @param {number} totalSpend - Total customer spend\n * @returns {Array} Profit optimization recommendations\n */\nexport const getProfitOptimizationRecommendations = (products, commitmentLevel, totalSpend) => {\n  const recommendations = [];\n\n  // Analyze each product\n  products.forEach(product => {\n    const optimalPricing = calculateOptimalPricing(product, product.qty, commitmentLevel, totalSpend);\n\n    // Quantity recommendations\n    if (optimalPricing.quantity.recommended > optimalPricing.quantity.current) {\n      recommendations.push({\n        type: 'quantity',\n        product: product.name,\n        message: `Increase ${product.name} quantity to ${optimalPricing.quantity.recommended} units to qualify for volume discount and improve margin.`,\n        potential: optimalPricing.quantity.potential\n      });\n    }\n\n    // Commitment recommendations\n    if (optimalPricing.commitment.recommended !== optimalPricing.commitment.current) {\n      const nextCommitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[optimalPricing.commitment.recommended];\n      recommendations.push({\n        type: 'commitment',\n        message: `Upgrade to ${nextCommitment.name} commitment to get ${(nextCommitment.discount * 100).toFixed(0)}% discount and improve profitability.`,\n        potential: optimalPricing.commitment.potential\n      });\n    }\n\n    // Upsell recommendations\n    optimalPricing.upsells.forEach(upsell => {\n      recommendations.push({\n        type: 'upsell',\n        name: upsell.name,\n        message: `Add ${upsell.name} to get ${upsell.features.join(', ')}.`,\n        potential: upsell.potential,\n        margin: upsell.margin\n      });\n    });\n  });\n\n  // Sort recommendations by potential value\n  return recommendations.sort((a, b) => b.potential - a.potential);\n};\n\n/**\n * Calculate total cost with all discounts and fees\n * @param {Object} product - Product object\n * @param {number} qty - Quantity\n * @param {boolean} isAnnual - Whether this is an annual commitment\n * @param {boolean} waiveFees - Whether to waive processing fees\n * @param {number} monthlyVolume - Monthly transaction volume\n * @param {number} totalSpend - Total customer spend\n * @param {Object} factors - Dynamic pricing factors\n * @returns {Object} Complete pricing details\n */\nexport const calculateTotalCost = (product, qty, isAnnual, waiveFees, monthlyVolume = 0, totalSpend = 0, factors = {}) => {\n  const pricingData = getPricingData(product, qty);\n  const dynamicPrice = calculateDynamicPricing(pricingData.recommendedPrice, factors);\n  const subtotal = dynamicPrice * qty;\n  const tax = subtotal * FINANCIAL_CONSTANTS.TAX_RATE;\n  const processingFee = calculatePaymentProcessingFee(subtotal + tax, isAnnual, waiveFees, monthlyVolume, totalSpend);\n  const loyaltyTier = getLoyaltyTier(totalSpend);\n  const feeReport = generateFeeReport(processingFee, monthlyVolume, totalSpend);\n\n  // Calculate commitment level\n  const commitmentLevel = isAnnual ? 'ANNUAL' : 'MONTHLY';\n  const commitmentPricing = calculateCommitmentPricing(dynamicPrice, commitmentLevel, qty);\n\n  // Get upsell opportunities with dynamic pricing\n  const upsellOpportunities = getUpsellOpportunities([product], commitmentLevel, totalSpend).map(upsell => ({\n    ...upsell,\n    dynamicPrice: calculateDynamicPricing(upsell.basePrice, factors)\n  }));\n\n  // Get profit optimization recommendations\n  const profitRecommendations = getProfitOptimizationRecommendations([product], commitmentLevel, totalSpend);\n  return {\n    subtotal,\n    tax,\n    processingFee: processingFee.fee,\n    total: subtotal + tax + processingFee.fee,\n    discounts: {\n      volume: pricingData.volumeDiscount,\n      seasonal: pricingData.seasonalDiscount,\n      total: pricingData.totalDiscount,\n      commitment: commitmentPricing.discount,\n      dynamic: factors.demandLevel ? (1 - FINANCIAL_CONSTANTS.DYNAMIC_PRICING.DEMAND_BASED[factors.demandLevel].multiplier) * 100 : 0\n    },\n    fees: {\n      processing: processingFee,\n      tax: FINANCIAL_CONSTANTS.TAX_RATE\n    },\n    loyalty: {\n      tier: loyaltyTier.name,\n      benefits: loyaltyTier.benefits\n    },\n    commitment: commitmentPricing,\n    upsellOpportunities,\n    profitRecommendations,\n    feeReport,\n    dynamicPricing: {\n      basePrice: pricingData.recommendedPrice,\n      adjustedPrice: dynamicPrice,\n      factors\n    },\n    isAnnual,\n    quantity: qty\n  };\n};\n\n/**\n * Get business recommendations based on current configuration\n * @param {Array} products - Array of selected products\n * @param {number} serviceCharge - Service charge amount\n * @param {string} billingCycle - Billing cycle (monthly/annual)\n * @param {number} profitBeforeTax - Profit before tax\n * @param {number} totalSpend - Total customer spend\n * @param {number} monthlyVolume - Monthly transaction volume\n * @returns {Array} Array of recommendations\n */\nexport const getRecommendations = (products, serviceCharge, billingCycle, profitBeforeTax, totalSpend = 0, monthlyVolume = 0) => {\n  if (!Array.isArray(products) || typeof serviceCharge !== 'number' || !['monthly', 'annual'].includes(billingCycle) || typeof profitBeforeTax !== 'number') {\n    throw new Error('Invalid input parameters');\n  }\n  const recommendations = [];\n  const selectedCategories = products.map(p => p.category);\n  const currentSeason = getCurrentSeasonalPricing();\n  const isAnnual = billingCycle === 'annual';\n\n  // Calculate total amount for fee waiver recommendations\n  const totalAmount = products.reduce((sum, p) => {\n    const pricingData = getPricingData(p, p.qty);\n    return sum + pricingData.recommendedPrice * p.qty;\n  }, 0);\n\n  // Loyalty tier recommendations\n  const currentTier = getLoyaltyTier(totalSpend);\n  const nextTier = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS).find(([, tier]) => tier.minSpend > currentTier.minSpend);\n  if (nextTier) {\n    const [, nextTierData] = nextTier;\n    const remainingForNextTier = nextTierData.minSpend - totalSpend;\n    recommendations.push(`Add $${remainingForNextTier.toFixed(2)} more to your total spend to reach ${nextTierData.name} tier and get ${(nextTierData.benefits.processingFeeDiscount * 100).toFixed(0)}% off processing fees.`);\n  }\n\n  // Volume-based fee tier recommendations\n  const currentFeeTier = getProcessingFeeTier(monthlyVolume);\n  const nextFeeTier = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES.find(tier => tier.minVolume > currentFeeTier.minVolume);\n  if (nextFeeTier) {\n    const remainingForNextTier = nextFeeTier.minVolume - monthlyVolume;\n    recommendations.push(`Increase your monthly volume by $${remainingForNextTier.toFixed(2)} to qualify for lower processing fees (${(nextFeeTier.percentageFee * 100).toFixed(2)}% + $${nextFeeTier.baseFee.toFixed(2)}).`);\n  }\n\n  // Payment processing fee recommendations\n  if (!isAnnual && totalAmount < FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER) {\n    const remainingForWaiver = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER - totalAmount;\n    recommendations.push(`Add $${remainingForWaiver.toFixed(2)} more to your order to qualify for automatic payment processing fee waiver.`);\n  }\n  if (!isAnnual && FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.ANNUAL_COMMITMENT_WAIVER) {\n    recommendations.push(\"Switch to annual billing to automatically waive payment processing fees.\");\n  }\n\n  // Add seasonal pricing recommendation\n  if (currentSeason.discount > 0) {\n    recommendations.push(`Take advantage of our ${currentSeason.name} with ${(currentSeason.discount * 100).toFixed(0)}% off!`);\n  }\n\n  // Volume discount recommendations\n  products.forEach(p => {\n    const nextVolumeTier = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS.find(tier => tier.minQty > p.qty);\n    if (nextVolumeTier) {\n      const additionalQty = nextVolumeTier.minQty - p.qty;\n      const potentialDiscount = nextVolumeTier.discount;\n      recommendations.push(`Add ${additionalQty} more ${p.name} units to qualify for ${(potentialDiscount * 100).toFixed(0)}% volume discount.`);\n    }\n  });\n\n  // 1. Margin improvement\n  const lowMarginProducts = products.filter(p => getPricingData(p, p.qty).margin < FINANCIAL_CONSTANTS.TARGET_MARGIN);\n  if (lowMarginProducts.length > 0) {\n    lowMarginProducts.forEach(p => {\n      const currentMargin = getPricingData(p, p.qty).margin;\n      recommendations.push(`Increase the margin for \"${p.name}\" (currently ${(currentMargin * 100).toFixed(1)}%) to at least ${(FINANCIAL_CONSTANTS.TARGET_MARGIN * 100).toFixed(1)}% to improve profitability.`);\n    });\n  }\n\n  // 2. Upsell higher-margin products\n  const highMarginProducts = products.filter(p => getPricingData(p, p.qty).margin >= FINANCIAL_CONSTANTS.HIGH_MARGIN);\n  if (highMarginProducts.length > 0) {\n    highMarginProducts.forEach(p => {\n      const margin = getPricingData(p, p.qty).margin;\n      recommendations.push(`Focus on upselling \"${p.name}\" (margin ${(margin * 100).toFixed(1)}%) for better profit.`);\n    });\n  }\n\n  // 3. Bundle services\n  if (products.length > 1) {\n    const bundleDiscount = FINANCIAL_CONSTANTS.ANNUAL_DISCOUNT_RATE * 100;\n    recommendations.push(`Bundle multiple products/services for a more attractive offer. Consider offering a ${bundleDiscount}% discount for annual commitments.`);\n  }\n\n  // 4. Service charge review\n  if (serviceCharge < FINANCIAL_CONSTANTS.MIN_SERVICE_FEE) {\n    recommendations.push(`Consider increasing your Professional Services & Support fee to at least $${FINANCIAL_CONSTANTS.MIN_SERVICE_FEE}/year to match industry averages.`);\n  }\n\n  // 5. Profitability check\n  if (profitBeforeTax < 0) {\n    recommendations.push(\"Warning: Your current configuration is not profitable. Review your pricing and costs.\");\n  } else if (profitBeforeTax < FINANCIAL_CONSTANTS.MIN_PROFIT_THRESHOLD) {\n    recommendations.push(`Your profit ($${profitBeforeTax.toFixed(2)}) is below the recommended threshold of $${FINANCIAL_CONSTANTS.MIN_PROFIT_THRESHOLD}. Consider increasing margins or service fees, or reducing costs.`);\n  } else {\n    recommendations.push(`Your configuration is profitable ($${profitBeforeTax.toFixed(2)}). Look for further upsell opportunities or cost optimizations.`);\n  }\n\n  // 6. Complementary product recommendations\n  const complementaryCategories = {\n    Desktop: [\"Server\", \"SaaS\"],\n    Server: [\"SaaS\", \"Virtual Server\"],\n    \"Virtual Server\": [\"SaaS\"],\n    SaaS: [\"Server\", \"Virtual Server\"]\n  };\n  const missingCategories = Object.entries(complementaryCategories).filter(([category]) => selectedCategories.includes(category)).flatMap(([, compCategories]) => compCategories.filter(cat => !selectedCategories.includes(cat))).filter((cat, index, self) => self.indexOf(cat) === index);\n  if (missingCategories.length > 0) {\n    const suggestedProduct = products.find(p => missingCategories.includes(p.category));\n    if (suggestedProduct) {\n      const potentialRevenue = formatCurrency(suggestedProduct.pricingSlabs[0].recommendedPrice * 5);\n      const annualRevenue = billingCycle === 'annual' ? formatCurrency(potentialRevenue * 12) : potentialRevenue;\n      recommendations.push(`Enhance your solution by adding a \"${suggestedProduct.category}\" product like \"${suggestedProduct.name}\". ` + `This can provide a more comprehensive backup strategy and increase your revenue by approximately $${annualRevenue} ${billingCycle === 'annual' ? 'per year' : 'per month'} for 5 units.`);\n    }\n  }\n  return recommendations;\n};\n\n/**\n * Calculate all derived fields for a product row (unit cost, margin, price, total, etc.)\n * @param {Product} product\n * @param {number} qty\n * @param {string} billingCycle\n * @returns {Object}\n */\nexport function calculateProductRow(product, qty, billingCycle) {\n  const isDR = product.isHomeGrown;\n  // Find the correct pricing slab\n  const slab = (product.pricingSlabs || []).find(slab => qty >= slab.minQty && qty <= slab.maxQty) || (product.pricingSlabs ? product.pricingSlabs[product.pricingSlabs.length - 1] : {\n    unitCost: 0,\n    margin: 0,\n    recommendedPrice: 0\n  });\n  // For non-DR, display unitCost with 13% tax for UI\n  let unitCost = typeof product.unitCost === 'number' ? product.unitCost : slab.unitCost;\n  if (!isDR) {\n    unitCost = unitCost * 1.13;\n  }\n  const margin = typeof product.margin === 'number' ? product.margin : slab.margin || 0;\n  // DR: price = unitCost * 1.13, others: unitCost * (1 + margin/100)\n  const price = isDR ? unitCost : unitCost * (1 + margin / 100);\n  // For DR, total is price (not price * qty), for others, total = price * qty * billingMultiplier\n  const billingMultiplier = billingCycle === 'annual' ? 12 : 1;\n  const total = isDR ? price : price * qty * billingMultiplier;\n  return {\n    ...product,\n    qty,\n    unitCost,\n    margin,\n    price,\n    total,\n    isDR,\n    slab\n  };\n}","map":{"version":3,"names":["FINANCIAL_CONSTANTS","ANNUAL_DISCOUNT_RATE","INDUSTRY_AVG_SERVICE_FEE","SERVICE_FEE_THRESHOLD_LOW","SERVICE_FEE_THRESHOLD_HIGH","TAX_RATE","DEFAULT_MARGIN","MIN_MARGIN","TARGET_MARGIN","HIGH_MARGIN","MIN_PROFIT_THRESHOLD","MIN_SERVICE_FEE","VOLUME_DISCOUNTS","minQty","discount","SEASONAL_PRICING","Q1","name","months","Q2","Q3","Q4","PAYMENT_PROCESSING","BASE_FEE","PERCENTAGE_FEE","MIN_AMOUNT_FOR_WAIVER","ANNUAL_COMMITMENT_WAIVER","TIERED_FEES","minVolume","baseFee","percentageFee","LOYALTY_TIERS","BRONZE","minSpend","benefits","processingFeeDiscount","serviceFeeDiscount","specialPromotions","SILVER","GOLD","prioritySupport","PLATINUM","dedicatedAccountManager","COMMITMENT_LEVELS","MONTHLY","minTerm","cancellationFee","features","QUARTERLY","BIANNUAL","ANNUAL","UPSELL_OPPORTUNITIES","PREMIUM_SUPPORT","basePrice","margin","minCommitment","ENTERPRISE_FEATURES","TRAINING_PACKAGE","CUSTOM_INTEGRATION","DEDICATED_SERVER","SECURITY_PACKAGE","DYNAMIC_PRICING","TIME_BASED","PEAK_HOURS","multiplier","hours","OFF_PEAK","DEMAND_BASED","HIGH","threshold","MEDIUM","LOW","CUSTOMER_BASED","NEW","RETURNING","LOYAL","PROFIT_OPTIMIZATION","MIN_COMMITMENT_DISCOUNT","MAX_COMMITMENT_DISCOUNT","BUNDLE_DISCOUNT","REFERRAL_BONUS","CROSS_SELL_THRESHOLD","UPSELL_THRESHOLD","RETENTION_BONUS","EARLY_RENEWAL_DISCOUNT","BULK_PURCHASE_THRESHOLD","BULK_PURCHASE_DISCOUNT","calculateVolumeDiscount","qty","applicableDiscount","filter","tier","sort","a","b","getCurrentSeasonalPricing","currentMonth","Date","getMonth","Object","values","find","period","includes","getPricingData","product","pricingSlabs","Error","Number","isInteger","forEach","slab","unitCost","isHomeGrown","maxQty","length","recommendedPrice","volumeDiscount","seasonalPricing","totalDiscount","Math","min","discountedPrice","formatCurrency","seasonalDiscount","seasonalPeriod","getPackageName","products","Array","isArray","amount","isNaN","isFinite","round","getLoyaltyTier","totalSpend","tiers","entries","getProcessingFeeTier","monthlyVolume","calculatePaymentProcessingFee","isAnnual","waiveFees","fee","percentage","isWaived","reason","feeTier","totalFee","loyaltyTier","loyaltyDiscount","discountedFee","qualifiesForWaiver","toLocaleString","originalFee","calculateFeeSavings","feeDetails","_loyaltySavings$next","_volumeSavings$next","_loyaltySavings$next2","_volumeSavings$next2","_loyaltySavings$next3","_volumeSavings$next3","currentTier","currentFeeTier","nextLoyaltyTier","loyaltySavings","current","monthlySavings","annualSavings","next","nextTierData","nextTierDiscount","potentialMonthlySavings","currentMonthlySavings","additionalMonthlySavings","additionalAnnualSavings","requiredSpend","nextFeeTier","volumeSavings","rate","monthlyFees","annualFees","potentialBaseFee","potentialPercentageFee","potentialMonthlyFees","currentMonthlyFees","potentialAnnualFees","requiredVolume","totalSavings","monthly","annual","potential","recommendations","generateSavingsRecommendations","push","type","message","toFixed","potentialSavings","generateFeeReport","savings","currentFees","waiverReason","currentSavings","loyaltyUpgrade","additionalDiscount","volumeUpgrade","newRate","newBaseFee","calculateCommitmentPricing","commitmentLevel","quantity","commitment","totalPrice","getUpsellOpportunities","currentProducts","opportunities","currentFeatures","Set","flatMap","p","key","opportunity","qualifies","newFeatures","f","has","price","potentialRevenue","calculateDynamicPricing","factors","adjustedPrice","currentHour","getHours","demandLevel","demandFactor","customerType","customerFactor","generateEmailSubject","customerName","quoteNumber","getFullYear","String","floor","random","padStart","commitmentName","date","toLocaleDateString","month","day","year","calculateOptimalPricing","currentMargin","dynamicBasePrice","strategies","recommended","upsells","crossSells","totalPotential","nextVolumeTier","bulkDiscount","nextCommitment","level","nextLevel","nextCommitmentData","additionalFeatures","map","upsell","dynamicPrice","opp","reduce","sum","crossSell","getProfitOptimizationRecommendations","optimalPricing","join","calculateTotalCost","pricingData","subtotal","tax","processingFee","feeReport","commitmentPricing","upsellOpportunities","profitRecommendations","total","discounts","volume","seasonal","dynamic","fees","processing","loyalty","dynamicPricing","getRecommendations","serviceCharge","billingCycle","profitBeforeTax","selectedCategories","category","currentSeason","totalAmount","nextTier","remainingForNextTier","remainingForWaiver","additionalQty","potentialDiscount","lowMarginProducts","highMarginProducts","bundleDiscount","complementaryCategories","Desktop","Server","SaaS","missingCategories","compCategories","cat","index","self","indexOf","suggestedProduct","annualRevenue","calculateProductRow","isDR","billingMultiplier"],"sources":["C:/Users/Hasan/Desktop/vscode/etcalc/src/utils/pricing.js"],"sourcesContent":["/**\n * @typedef {Object} Product\n * @property {string} name\n * @property {string} description\n * @property {string} license\n * @property {string} [category]\n * @property {Array<{minQty: number, maxQty: number, unitCost: number, margin?: number, recommendedPrice: number}>} pricingSlabs\n * @property {number} [unitCost]\n * @property {number} [margin]\n * @property {boolean} [isHomeGrown]\n * @property {number} [qty]\n */\n\n// Constants for financial calculations\nexport const FINANCIAL_CONSTANTS = {\n  ANNUAL_DISCOUNT_RATE: 0.03,\n  INDUSTRY_AVG_SERVICE_FEE: 100,\n  SERVICE_FEE_THRESHOLD_LOW: 0.8,\n  SERVICE_FEE_THRESHOLD_HIGH: 1.2,\n  TAX_RATE: 0.13,\n  DEFAULT_MARGIN: 0.35,\n  MIN_MARGIN: 0.20,\n  TARGET_MARGIN: 0.35,\n  HIGH_MARGIN: 0.40,\n  MIN_PROFIT_THRESHOLD: 200,\n  MIN_SERVICE_FEE: 100,\n  // Volume discount tiers\n  VOLUME_DISCOUNTS: [\n    { minQty: 5, discount: 0.05 },  // 5% off for 5+ units\n    { minQty: 10, discount: 0.10 }, // 10% off for 10+ units\n    { minQty: 20, discount: 0.15 }, // 15% off for 20+ units\n    { minQty: 50, discount: 0.20 }  // 20% off for 50+ units\n  ],\n  // Seasonal pricing periods\n  SEASONAL_PRICING: {\n    Q1: { name: \"New Year Special\", discount: 0.10, months: [0, 1, 2] },    // Jan-Mar\n    Q2: { name: \"Spring Promotion\", discount: 0.05, months: [3, 4, 5] },    // Apr-Jun\n    Q3: { name: \"Summer Sale\", discount: 0.15, months: [6, 7, 8] },         // Jul-Sep\n    Q4: { name: \"Year-End Deal\", discount: 0.20, months: [9, 10, 11] }      // Oct-Dec\n  },\n  // Payment processing fee constants\n  PAYMENT_PROCESSING: {\n    BASE_FEE: 0.30,\n    PERCENTAGE_FEE: 0.0299,\n    MIN_AMOUNT_FOR_WAIVER: 1000, // Minimum amount to qualify for fee waiver\n    ANNUAL_COMMITMENT_WAIVER: true, // Whether annual commitments qualify for fee waiver\n    // Tiered processing fees based on monthly transaction volume\n    TIERED_FEES: [\n      { minVolume: 0, baseFee: 0.30, percentageFee: 0.0299 },\n      { minVolume: 10000, baseFee: 0.25, percentageFee: 0.0275 },\n      { minVolume: 50000, baseFee: 0.20, percentageFee: 0.0250 },\n      { minVolume: 100000, baseFee: 0.15, percentageFee: 0.0225 },\n      { minVolume: 500000, baseFee: 0.10, percentageFee: 0.0200 }\n    ]\n  },\n  // Customer loyalty tiers\n  LOYALTY_TIERS: {\n    BRONZE: {\n      name: \"Bronze\",\n      minSpend: 0,\n      benefits: {\n        processingFeeDiscount: 0,\n        serviceFeeDiscount: 0,\n        specialPromotions: false\n      }\n    },\n    SILVER: {\n      name: \"Silver\",\n      minSpend: 5000,\n      benefits: {\n        processingFeeDiscount: 0.25, // 25% off processing fees\n        serviceFeeDiscount: 0.10,    // 10% off service fees\n        specialPromotions: true\n      }\n    },\n    GOLD: {\n      name: \"Gold\",\n      minSpend: 20000,\n      benefits: {\n        processingFeeDiscount: 0.50, // 50% off processing fees\n        serviceFeeDiscount: 0.20,    // 20% off service fees\n        specialPromotions: true,\n        prioritySupport: true\n      }\n    },\n    PLATINUM: {\n      name: \"Platinum\",\n      minSpend: 50000,\n      benefits: {\n        processingFeeDiscount: 1.00, // 100% off processing fees\n        serviceFeeDiscount: 0.30,    // 30% off service fees\n        specialPromotions: true,\n        prioritySupport: true,\n        dedicatedAccountManager: true\n      }\n    }\n  },\n  // Enhanced commitment levels\n  COMMITMENT_LEVELS: {\n    MONTHLY: {\n      name: \"Monthly\",\n      discount: 0,\n      minTerm: 1,\n      cancellationFee: 0,\n      features: [\"Basic Support\", \"Standard Features\"]\n    },\n    QUARTERLY: {\n      name: \"Quarterly\",\n      discount: 0.05,\n      minTerm: 3,\n      cancellationFee: 0.1,\n      features: [\"Priority Support\", \"Advanced Features\", \"Monthly Reports\"]\n    },\n    BIANNUAL: {\n      name: \"Bi-Annual\",\n      discount: 0.10,\n      minTerm: 6,\n      cancellationFee: 0.15,\n      features: [\"Premium Support\", \"Enterprise Features\", \"Quarterly Reviews\"]\n    },\n    ANNUAL: {\n      name: \"Annual\",\n      discount: 0.15,\n      minTerm: 12,\n      cancellationFee: 0.2,\n      features: [\"24/7 Support\", \"All Features\", \"Quarterly Reviews\", \"Dedicated Account Manager\"]\n    }\n  },\n  // Enhanced upsell opportunities\n  UPSELL_OPPORTUNITIES: {\n    PREMIUM_SUPPORT: {\n      name: \"Premium Support\",\n      basePrice: 199,\n      margin: 0.75,\n      minCommitment: \"QUARTERLY\",\n      features: [\n        \"24/7 Priority Support\",\n        \"Dedicated Account Manager\",\n        \"Custom Integration Support\",\n        \"Advanced Analytics\"\n      ]\n    },\n    ENTERPRISE_FEATURES: {\n      name: \"Enterprise Features\",\n      basePrice: 299,\n      margin: 0.80,\n      minCommitment: \"BIANNUAL\",\n      features: [\n        \"Custom Workflows\",\n        \"API Access\",\n        \"Advanced Security\",\n        \"Multi-region Support\"\n      ]\n    },\n    TRAINING_PACKAGE: {\n      name: \"Training Package\",\n      basePrice: 499,\n      margin: 0.85,\n      minCommitment: \"QUARTERLY\",\n      features: [\n        \"On-site Training\",\n        \"Custom Documentation\",\n        \"Best Practices Guide\",\n        \"Ongoing Support\"\n      ]\n    },\n    CUSTOM_INTEGRATION: {\n      name: \"Custom Integration\",\n      basePrice: 999,\n      margin: 0.90,\n      minCommitment: \"ANNUAL\",\n      features: [\n        \"Custom API Development\",\n        \"Integration Testing\",\n        \"Performance Optimization\",\n        \"Ongoing Maintenance\"\n      ]\n    },\n    DEDICATED_SERVER: {\n      name: \"Dedicated Server\",\n      basePrice: 799,\n      margin: 0.85,\n      minCommitment: \"ANNUAL\",\n      features: [\n        \"Dedicated Hardware\",\n        \"Custom Configuration\",\n        \"24/7 Monitoring\",\n        \"Backup Solutions\"\n      ]\n    },\n    SECURITY_PACKAGE: {\n      name: \"Security Package\",\n      basePrice: 399,\n      margin: 0.80,\n      minCommitment: \"QUARTERLY\",\n      features: [\n        \"Advanced Encryption\",\n        \"Security Auditing\",\n        \"Compliance Support\",\n        \"Regular Security Updates\"\n      ]\n    }\n  },\n  // Dynamic pricing factors\n  DYNAMIC_PRICING: {\n    TIME_BASED: {\n      PEAK_HOURS: { multiplier: 1.1, hours: [9, 10, 11, 14, 15, 16] },\n      OFF_PEAK: { multiplier: 0.9, hours: [0, 1, 2, 3, 4, 5, 6, 7, 8, 20, 21, 22, 23] }\n    },\n    DEMAND_BASED: {\n      HIGH: { threshold: 0.8, multiplier: 1.15 },\n      MEDIUM: { threshold: 0.5, multiplier: 1.0 },\n      LOW: { threshold: 0.2, multiplier: 0.85 }\n    },\n    CUSTOMER_BASED: {\n      NEW: { multiplier: 1.0 },\n      RETURNING: { multiplier: 0.95 },\n      LOYAL: { multiplier: 0.90 }\n    }\n  },\n  // Enhanced profit optimization\n  PROFIT_OPTIMIZATION: {\n    MIN_MARGIN: 0.30,\n    TARGET_MARGIN: 0.40,\n    HIGH_MARGIN: 0.50,\n    MIN_COMMITMENT_DISCOUNT: 0.05,\n    MAX_COMMITMENT_DISCOUNT: 0.20,\n    BUNDLE_DISCOUNT: 0.10,\n    REFERRAL_BONUS: 0.05,\n    CROSS_SELL_THRESHOLD: 0.15,\n    UPSELL_THRESHOLD: 0.25,\n    RETENTION_BONUS: 0.10,\n    EARLY_RENEWAL_DISCOUNT: 0.08,\n    BULK_PURCHASE_THRESHOLD: 10,\n    BULK_PURCHASE_DISCOUNT: 0.15\n  }\n};\n\n/**\n * Calculate volume discount based on quantity\n * @param {number} qty - Quantity\n * @returns {number} Discount percentage (0-1)\n */\nexport const calculateVolumeDiscount = (qty) => {\n  const applicableDiscount = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS\n    .filter(tier => qty >= tier.minQty)\n    .sort((a, b) => b.discount - a.discount)[0];\n  \n  return applicableDiscount ? applicableDiscount.discount : 0;\n};\n\n/**\n * Get current seasonal pricing period\n * @returns {Object} Seasonal pricing period info\n */\nexport const getCurrentSeasonalPricing = () => {\n  const currentMonth = new Date().getMonth();\n  return Object.values(FINANCIAL_CONSTANTS.SEASONAL_PRICING)\n    .find(period => period.months.includes(currentMonth)) || \n    { name: \"Standard Pricing\", discount: 0 };\n};\n\n/**\n * Get pricing data for a product based on quantity\n * @param {Object} product - Product object\n * @param {number} qty - Quantity\n * @returns {Object} Pricing slab data with discounts applied\n * @throws {Error} If product or quantity is invalid\n */\nexport const getPricingData = (product, qty) => {\n  if (!product || !product.pricingSlabs) {\n    throw new Error('Invalid product data');\n  }\n  \n  if (!Number.isInteger(qty) || qty < 1) {\n    throw new Error('Quantity must be a positive integer');\n  }\n\n  // Validate pricing slabs\n  product.pricingSlabs.forEach(slab => {\n    if (slab.unitCost < 0) {\n      throw new Error(`Invalid unit cost (${slab.unitCost}) for product ${product.name}`);\n    }\n    // Only enforce margin for non-homegrown products\n    if (!product.isHomeGrown && slab.margin < FINANCIAL_CONSTANTS.MIN_MARGIN) {\n      throw new Error(`Margin (${slab.margin}) below minimum threshold for product ${product.name}`);\n    }\n  });\n\n  const slab = product.pricingSlabs.find(\n    slab => qty >= slab.minQty && qty <= slab.maxQty\n  ) || product.pricingSlabs[product.pricingSlabs.length - 1];\n\n  // For home-grown products, recommendedPrice = unitCost * 1.13\n  let recommendedPrice = slab.recommendedPrice;\n  if (product.isHomeGrown) {\n    recommendedPrice = slab.unitCost * 1.13;\n  }\n\n  // Calculate discounts\n  const volumeDiscount = calculateVolumeDiscount(qty);\n  const seasonalPricing = getCurrentSeasonalPricing();\n  const totalDiscount = Math.min(volumeDiscount + seasonalPricing.discount, 0.30); // Cap total discount at 30%\n\n  // Apply discounts to recommended price\n  const discountedPrice = recommendedPrice * (1 - totalDiscount);\n\n  return {\n    ...slab,\n    recommendedPrice: formatCurrency(discountedPrice),\n    volumeDiscount,\n    seasonalDiscount: seasonalPricing.discount,\n    totalDiscount,\n    seasonalPeriod: seasonalPricing.name\n  };\n};\n\n/**\n * Get package name based on number of products\n * @param {Array} products - Array of products\n * @returns {string} Package name\n */\nexport const getPackageName = (products) => {\n  if (!Array.isArray(products)) {\n    throw new Error('Invalid products array');\n  }\n  return products.length >= 2 ? \"Backup Total\" : \"Backup Basic\";\n};\n\n/**\n * Calculate total cost with proper decimal handling\n * @param {number} amount - Amount to format\n * @returns {number} Formatted amount with 2 decimal places\n */\nexport const formatCurrency = (amount) => {\n  if (typeof amount !== 'number' || isNaN(amount)) {\n    throw new Error('Invalid amount for currency formatting');\n  }\n  if (!isFinite(amount)) {\n    throw new Error('Amount must be a finite number');\n  }\n  return Number(Math.round(amount + 'e2') + 'e-2');\n};\n\n/**\n * Get customer loyalty tier based on total spend\n * @param {number} totalSpend - Total customer spend\n * @returns {Object} Loyalty tier details\n */\nexport const getLoyaltyTier = (totalSpend) => {\n  const tiers = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS)\n    .sort(([, a], [, b]) => b.minSpend - a.minSpend);\n\n  for (const [, tier] of tiers) {\n    if (totalSpend >= tier.minSpend) {\n      return tier;\n    }\n  }\n  return FINANCIAL_CONSTANTS.LOYALTY_TIERS.BRONZE;\n};\n\n/**\n * Get tiered processing fee based on monthly volume\n * @param {number} monthlyVolume - Monthly transaction volume\n * @returns {Object} Fee tier details\n */\nexport const getProcessingFeeTier = (monthlyVolume) => {\n  const tiers = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES\n    .sort((a, b) => b.minVolume - a.minVolume);\n\n  for (const tier of tiers) {\n    if (monthlyVolume >= tier.minVolume) {\n      return tier;\n    }\n  }\n  return tiers[tiers.length - 1];\n};\n\n/**\n * Calculate payment processing fee\n * @param {number} amount - Transaction amount\n * @param {boolean} isAnnual - Whether this is an annual commitment\n * @param {boolean} waiveFees - Whether to waive the fees\n * @param {number} monthlyVolume - Monthly transaction volume\n * @param {number} totalSpend - Total customer spend\n * @returns {Object} Fee details\n */\nexport const calculatePaymentProcessingFee = (amount, isAnnual, waiveFees, monthlyVolume = 0, totalSpend = 0) => {\n  if (waiveFees) {\n    return {\n      fee: 0,\n      percentage: 0,\n      baseFee: 0,\n      isWaived: true,\n      reason: isAnnual ? \"Annual commitment\" : \"Fee waiver applied\"\n    };\n  }\n\n  // Get applicable fee tier\n  const feeTier = getProcessingFeeTier(monthlyVolume);\n  const baseFee = feeTier.baseFee;\n  const percentageFee = amount * feeTier.percentageFee;\n  const totalFee = baseFee + percentageFee;\n\n  // Get loyalty tier benefits\n  const loyaltyTier = getLoyaltyTier(totalSpend);\n  const loyaltyDiscount = loyaltyTier.benefits.processingFeeDiscount;\n  const discountedFee = totalFee * (1 - loyaltyDiscount);\n\n  // Check if amount qualifies for automatic waiver\n  const qualifiesForWaiver = amount >= FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER ||\n    (isAnnual && FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.ANNUAL_COMMITMENT_WAIVER) ||\n    loyaltyTier.name === \"PLATINUM\";\n\n  return {\n    fee: qualifiesForWaiver ? 0 : discountedFee,\n    percentage: feeTier.percentageFee,\n    baseFee,\n    isWaived: qualifiesForWaiver,\n    reason: qualifiesForWaiver ? \n      (isAnnual ? \"Annual commitment\" : \n       loyaltyTier.name === \"PLATINUM\" ? \"Platinum tier benefit\" :\n       \"Amount exceeds minimum threshold\") : \n      \"Standard processing fee\",\n    loyaltyTier: loyaltyTier.name,\n    feeTier: `$${feeTier.minVolume.toLocaleString()}+`,\n    originalFee: totalFee,\n    loyaltyDiscount: loyaltyDiscount * 100\n  };\n};\n\n/**\n * Calculate fee savings analytics\n * @param {Object} feeDetails - Fee calculation details\n * @param {number} monthlyVolume - Monthly transaction volume\n * @param {number} totalSpend - Total customer spend\n * @returns {Object} Fee savings analytics\n */\nexport const calculateFeeSavings = (feeDetails, monthlyVolume, totalSpend) => {\n  const currentTier = getLoyaltyTier(totalSpend);\n  const currentFeeTier = getProcessingFeeTier(monthlyVolume);\n  \n  // Calculate potential savings from next loyalty tier\n  const nextLoyaltyTier = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS)\n    .find(([, tier]) => tier.minSpend > currentTier.minSpend);\n  \n  let loyaltySavings = {\n    current: {\n      tier: currentTier.name,\n      discount: currentTier.benefits.processingFeeDiscount * 100,\n      monthlySavings: feeDetails.originalFee * currentTier.benefits.processingFeeDiscount,\n      annualSavings: feeDetails.originalFee * currentTier.benefits.processingFeeDiscount * 12\n    },\n    next: null\n  };\n\n  if (nextLoyaltyTier) {\n    const [, nextTierData] = nextLoyaltyTier;\n    const nextTierDiscount = nextTierData.benefits.processingFeeDiscount;\n    const potentialMonthlySavings = feeDetails.originalFee * nextTierDiscount;\n    const currentMonthlySavings = feeDetails.originalFee * currentTier.benefits.processingFeeDiscount;\n    \n    loyaltySavings.next = {\n      tier: nextTierData.name,\n      discount: nextTierDiscount * 100,\n      additionalMonthlySavings: potentialMonthlySavings - currentMonthlySavings,\n      additionalAnnualSavings: (potentialMonthlySavings - currentMonthlySavings) * 12,\n      requiredSpend: nextTierData.minSpend - totalSpend\n    };\n  }\n\n  // Calculate potential savings from next fee tier\n  const nextFeeTier = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES\n    .find(tier => tier.minVolume > currentFeeTier.minVolume);\n  \n  let volumeSavings = {\n    current: {\n      tier: `$${currentFeeTier.minVolume.toLocaleString()}+`,\n      rate: currentFeeTier.percentageFee * 100,\n      baseFee: currentFeeTier.baseFee,\n      monthlyFees: feeDetails.originalFee,\n      annualFees: feeDetails.originalFee * 12\n    },\n    next: null\n  };\n\n  if (nextFeeTier) {\n    const potentialBaseFee = nextFeeTier.baseFee;\n    const potentialPercentageFee = monthlyVolume * nextFeeTier.percentageFee;\n    const potentialMonthlyFees = potentialBaseFee + potentialPercentageFee;\n    const currentMonthlyFees = feeDetails.originalFee;\n    \n    volumeSavings.next = {\n      tier: `$${nextFeeTier.minVolume.toLocaleString()}+`,\n      rate: nextFeeTier.percentageFee * 100,\n      baseFee: nextFeeTier.baseFee,\n      potentialMonthlyFees,\n      potentialAnnualFees: potentialMonthlyFees * 12,\n      monthlySavings: currentMonthlyFees - potentialMonthlyFees,\n      annualSavings: (currentMonthlyFees - potentialMonthlyFees) * 12,\n      requiredVolume: nextFeeTier.minVolume - monthlyVolume\n    };\n  }\n\n  // Calculate total savings\n  const totalSavings = {\n    current: {\n      monthly: loyaltySavings.current.monthlySavings,\n      annual: loyaltySavings.current.annualSavings,\n      percentage: (loyaltySavings.current.monthlySavings / feeDetails.originalFee) * 100\n    },\n    potential: {\n      monthly: (loyaltySavings.next?.additionalMonthlySavings || 0) + \n               (volumeSavings.next?.monthlySavings || 0),\n      annual: (loyaltySavings.next?.additionalAnnualSavings || 0) + \n              (volumeSavings.next?.annualSavings || 0),\n      percentage: ((loyaltySavings.next?.additionalMonthlySavings || 0) + \n                  (volumeSavings.next?.monthlySavings || 0)) / feeDetails.originalFee * 100\n    }\n  };\n\n  return {\n    loyaltySavings,\n    volumeSavings,\n    totalSavings,\n    recommendations: generateSavingsRecommendations(loyaltySavings, volumeSavings)\n  };\n};\n\n/**\n * Generate savings recommendations\n * @param {Object} loyaltySavings - Loyalty tier savings details\n * @param {Object} volumeSavings - Volume tier savings details\n * @returns {Array} Array of savings recommendations\n */\nconst generateSavingsRecommendations = (loyaltySavings, volumeSavings) => {\n  const recommendations = [];\n\n  if (loyaltySavings.next) {\n    recommendations.push({\n      type: 'loyalty',\n      message: `Upgrade to ${loyaltySavings.next.tier} tier by spending $${loyaltySavings.next.requiredSpend.toFixed(2)} more to save an additional $${loyaltySavings.next.additionalMonthlySavings.toFixed(2)}/month on processing fees.`,\n      potentialSavings: {\n        monthly: loyaltySavings.next.additionalMonthlySavings,\n        annual: loyaltySavings.next.additionalAnnualSavings\n      }\n    });\n  }\n\n  if (volumeSavings.next) {\n    recommendations.push({\n      type: 'volume',\n      message: `Increase monthly volume by $${volumeSavings.next.requiredVolume.toFixed(2)} to qualify for the ${volumeSavings.next.tier} tier and save $${volumeSavings.next.monthlySavings.toFixed(2)}/month on processing fees.`,\n      potentialSavings: {\n        monthly: volumeSavings.next.monthlySavings,\n        annual: volumeSavings.next.annualSavings\n      }\n    });\n  }\n\n  return recommendations;\n};\n\n/**\n * Generate detailed fee report\n * @param {Object} feeDetails - Fee calculation details\n * @param {number} monthlyVolume - Monthly transaction volume\n * @param {number} totalSpend - Total customer spend\n * @returns {Object} Detailed fee report\n */\nexport const generateFeeReport = (feeDetails, monthlyVolume, totalSpend) => {\n  const savings = calculateFeeSavings(feeDetails, monthlyVolume, totalSpend);\n  \n  return {\n    currentFees: {\n      baseFee: feeDetails.baseFee,\n      percentageFee: feeDetails.percentage * 100,\n      totalFee: feeDetails.fee,\n      isWaived: feeDetails.isWaived,\n      waiverReason: feeDetails.reason\n    },\n    currentSavings: {\n      loyaltyTier: savings.loyaltySavings.current.tier,\n      loyaltyDiscount: savings.loyaltySavings.current.discount,\n      monthlySavings: savings.loyaltySavings.current.monthlySavings,\n      annualSavings: savings.loyaltySavings.current.annualSavings\n    },\n    potentialSavings: {\n      loyaltyUpgrade: savings.loyaltySavings.next ? {\n        tier: savings.loyaltySavings.next.tier,\n        additionalDiscount: savings.loyaltySavings.next.discount - savings.loyaltySavings.current.discount,\n        monthlySavings: savings.loyaltySavings.next.additionalMonthlySavings,\n        annualSavings: savings.loyaltySavings.next.additionalAnnualSavings,\n        requiredSpend: savings.loyaltySavings.next.requiredSpend\n      } : null,\n      volumeUpgrade: savings.volumeSavings.next ? {\n        tier: savings.volumeSavings.next.tier,\n        newRate: savings.volumeSavings.next.rate,\n        newBaseFee: savings.volumeSavings.next.baseFee,\n        monthlySavings: savings.volumeSavings.next.monthlySavings,\n        annualSavings: savings.volumeSavings.next.annualSavings,\n        requiredVolume: savings.volumeSavings.next.requiredVolume\n      } : null\n    },\n    totalSavings: {\n      current: {\n        monthly: savings.totalSavings.current.monthly,\n        annual: savings.totalSavings.current.annual,\n        percentage: savings.totalSavings.current.percentage\n      },\n      potential: {\n        monthly: savings.totalSavings.potential.monthly,\n        annual: savings.totalSavings.potential.annual,\n        percentage: savings.totalSavings.potential.percentage\n      }\n    },\n    recommendations: savings.recommendations\n  };\n};\n\n/**\n * Calculate commitment-based pricing\n * @param {number} basePrice - Base price of the product\n * @param {string} commitmentLevel - Commitment level (MONTHLY, QUARTERLY, etc.)\n * @param {number} quantity - Number of units\n * @returns {Object} Commitment pricing details\n */\nexport const calculateCommitmentPricing = (basePrice, commitmentLevel, quantity) => {\n  const commitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel];\n  if (!commitment) {\n    throw new Error('Invalid commitment level');\n  }\n\n  const discount = commitment.discount;\n  const discountedPrice = basePrice * (1 - discount);\n  const totalPrice = discountedPrice * quantity;\n  const savings = basePrice * quantity - totalPrice;\n\n  return {\n    commitmentLevel: commitment.name,\n    basePrice,\n    discountedPrice,\n    quantity,\n    totalPrice,\n    savings,\n    discount: discount * 100,\n    minTerm: commitment.minTerm,\n    cancellationFee: commitment.cancellationFee * 100\n  };\n};\n\n/**\n * Get available upsell opportunities\n * @param {Array} currentProducts - Current product selection\n * @param {string} commitmentLevel - Current commitment level\n * @param {number} totalSpend - Total customer spend\n * @returns {Array} Available upsell opportunities\n */\nexport const getUpsellOpportunities = (currentProducts, commitmentLevel, totalSpend) => {\n  const opportunities = [];\n  const currentFeatures = new Set(currentProducts.flatMap(p => p.features || []));\n  \n  Object.entries(FINANCIAL_CONSTANTS.UPSELL_OPPORTUNITIES).forEach(([key, opportunity]) => {\n    // Check if customer qualifies for this upsell\n    const commitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[opportunity.minCommitment];\n    const qualifies = commitment && \n      FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel].minTerm >= commitment.minTerm;\n\n    if (qualifies) {\n      const newFeatures = opportunity.features.filter(f => !currentFeatures.has(f));\n      if (newFeatures.length > 0) {\n        opportunities.push({\n          ...opportunity,\n          key,\n          newFeatures,\n          price: calculateCommitmentPricing(\n            opportunity.basePrice,\n            commitmentLevel,\n            1\n          ),\n          potentialRevenue: opportunity.basePrice * (1 - FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel].discount),\n          margin: opportunity.margin * 100\n        });\n      }\n    }\n  });\n\n  return opportunities;\n};\n\n/**\n * Calculate dynamic pricing based on various factors\n * @param {number} basePrice - Base price of the product\n * @param {Object} factors - Pricing factors\n * @returns {number} Adjusted price\n */\nexport const calculateDynamicPricing = (basePrice, factors = {}) => {\n  let adjustedPrice = basePrice;\n  const currentHour = new Date().getHours();\n  \n  // Time-based pricing\n  if (FINANCIAL_CONSTANTS.DYNAMIC_PRICING.TIME_BASED.PEAK_HOURS.hours.includes(currentHour)) {\n    adjustedPrice *= FINANCIAL_CONSTANTS.DYNAMIC_PRICING.TIME_BASED.PEAK_HOURS.multiplier;\n  } else if (FINANCIAL_CONSTANTS.DYNAMIC_PRICING.TIME_BASED.OFF_PEAK.hours.includes(currentHour)) {\n    adjustedPrice *= FINANCIAL_CONSTANTS.DYNAMIC_PRICING.TIME_BASED.OFF_PEAK.multiplier;\n  }\n  \n  // Demand-based pricing\n  if (factors.demandLevel) {\n    const demandFactor = FINANCIAL_CONSTANTS.DYNAMIC_PRICING.DEMAND_BASED[factors.demandLevel];\n    if (demandFactor) {\n      adjustedPrice *= demandFactor.multiplier;\n    }\n  }\n  \n  // Customer-based pricing\n  if (factors.customerType) {\n    const customerFactor = FINANCIAL_CONSTANTS.DYNAMIC_PRICING.CUSTOMER_BASED[factors.customerType];\n    if (customerFactor) {\n      adjustedPrice *= customerFactor.multiplier;\n    }\n  }\n  \n  return formatCurrency(adjustedPrice);\n};\n\n/**\n * Generate email subject with customer name\n * @param {string} customerName - Customer's name\n * @param {string} commitmentLevel - Commitment level\n * @returns {string} Formatted email subject\n */\nexport const generateEmailSubject = (customerName, commitmentLevel) => {\n  const quoteNumber = `QT${new Date().getFullYear()}${String(Math.floor(1000 + Math.random() * 9000)).padStart(4, '0')}`;\n  const commitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel];\n  const commitmentName = commitment ? commitment.name : 'Standard';\n  const date = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });\n  return `[${quoteNumber}] ExcelyTech Quote - ${customerName || \"Customer\"} | ${commitmentName} Plan | ${date}`;\n};\n\n/**\n * Calculate optimal pricing strategy with enhanced features\n * @param {Object} product - Product details\n * @param {number} quantity - Current quantity\n * @param {string} commitmentLevel - Current commitment level\n * @param {number} totalSpend - Total customer spend\n * @param {Object} factors - Dynamic pricing factors\n * @returns {Object} Optimal pricing strategy\n */\nexport const calculateOptimalPricing = (product, quantity, commitmentLevel, totalSpend, factors = {}) => {\n  const currentMargin = getPricingData(product, quantity).margin;\n  const loyaltyTier = getLoyaltyTier(totalSpend);\n  const commitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[commitmentLevel];\n  \n  // Calculate dynamic base price\n  const dynamicBasePrice = calculateDynamicPricing(\n    product.pricingSlabs[0].recommendedPrice,\n    factors\n  );\n  \n  const strategies = {\n    quantity: {\n      current: quantity,\n      recommended: quantity,\n      potential: 0\n    },\n    commitment: {\n      current: commitmentLevel,\n      recommended: commitmentLevel,\n      potential: 0\n    },\n    upsells: [],\n    crossSells: [],\n    totalPotential: 0\n  };\n\n  // Enhanced quantity optimization\n  if (currentMargin < FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.TARGET_MARGIN) {\n    const nextVolumeTier = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS\n      .find(tier => tier.minQty > quantity);\n    \n    if (nextVolumeTier) {\n      strategies.quantity.recommended = nextVolumeTier.minQty;\n      strategies.quantity.potential = (nextVolumeTier.minQty - quantity) * dynamicBasePrice;\n      \n      // Add bulk purchase discount if applicable\n      if (nextVolumeTier.minQty >= FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.BULK_PURCHASE_THRESHOLD) {\n        strategies.quantity.bulkDiscount = FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.BULK_PURCHASE_DISCOUNT * 100;\n      }\n    }\n  }\n\n  // Enhanced commitment optimization\n  const nextCommitment = Object.entries(FINANCIAL_CONSTANTS.COMMITMENT_LEVELS)\n    .find(([key, level]) => level.minTerm > commitment.minTerm);\n  \n  if (nextCommitment) {\n    const [nextLevel, nextCommitmentData] = nextCommitment;\n    strategies.commitment.recommended = nextLevel;\n    strategies.commitment.potential = dynamicBasePrice * \n      quantity * (nextCommitmentData.discount - commitment.discount);\n    strategies.commitment.additionalFeatures = nextCommitmentData.features\n      .filter(f => !commitment.features.includes(f));\n  }\n\n  // Enhanced upsell opportunities\n  strategies.upsells = getUpsellOpportunities([product], commitmentLevel, totalSpend)\n    .map(upsell => ({\n      name: upsell.name,\n      potential: upsell.potentialRevenue,\n      margin: upsell.margin,\n      features: upsell.newFeatures,\n      dynamicPrice: calculateDynamicPricing(upsell.basePrice, factors)\n    }));\n\n  // Cross-sell opportunities\n  if (currentMargin >= FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.CROSS_SELL_THRESHOLD) {\n    strategies.crossSells = Object.entries(FINANCIAL_CONSTANTS.UPSELL_OPPORTUNITIES)\n      .filter(([key, opp]) => opp.margin >= FINANCIAL_CONSTANTS.PROFIT_OPTIMIZATION.UPSELL_THRESHOLD)\n      .map(([key, opp]) => ({\n        name: opp.name,\n        potential: opp.basePrice * (1 - commitment.discount),\n        margin: opp.margin,\n        features: opp.features,\n        dynamicPrice: calculateDynamicPricing(opp.basePrice, factors)\n      }));\n  }\n\n  // Calculate total potential\n  strategies.totalPotential = strategies.quantity.potential + \n    strategies.commitment.potential + \n    strategies.upsells.reduce((sum, upsell) => sum + upsell.potential, 0) +\n    strategies.crossSells.reduce((sum, crossSell) => sum + crossSell.potential, 0);\n\n  return strategies;\n};\n\n/**\n * Generate profit optimization recommendations\n * @param {Array} products - Current product selection\n * @param {string} commitmentLevel - Current commitment level\n * @param {number} totalSpend - Total customer spend\n * @returns {Array} Profit optimization recommendations\n */\nexport const getProfitOptimizationRecommendations = (products, commitmentLevel, totalSpend) => {\n  const recommendations = [];\n  \n  // Analyze each product\n  products.forEach(product => {\n    const optimalPricing = calculateOptimalPricing(\n      product,\n      product.qty,\n      commitmentLevel,\n      totalSpend\n    );\n\n    // Quantity recommendations\n    if (optimalPricing.quantity.recommended > optimalPricing.quantity.current) {\n      recommendations.push({\n        type: 'quantity',\n        product: product.name,\n        message: `Increase ${product.name} quantity to ${optimalPricing.quantity.recommended} units to qualify for volume discount and improve margin.`,\n        potential: optimalPricing.quantity.potential\n      });\n    }\n\n    // Commitment recommendations\n    if (optimalPricing.commitment.recommended !== optimalPricing.commitment.current) {\n      const nextCommitment = FINANCIAL_CONSTANTS.COMMITMENT_LEVELS[optimalPricing.commitment.recommended];\n      recommendations.push({\n        type: 'commitment',\n        message: `Upgrade to ${nextCommitment.name} commitment to get ${(nextCommitment.discount * 100).toFixed(0)}% discount and improve profitability.`,\n        potential: optimalPricing.commitment.potential\n      });\n    }\n\n    // Upsell recommendations\n    optimalPricing.upsells.forEach(upsell => {\n      recommendations.push({\n        type: 'upsell',\n        name: upsell.name,\n        message: `Add ${upsell.name} to get ${upsell.features.join(', ')}.`,\n        potential: upsell.potential,\n        margin: upsell.margin\n      });\n    });\n  });\n\n  // Sort recommendations by potential value\n  return recommendations.sort((a, b) => b.potential - a.potential);\n};\n\n/**\n * Calculate total cost with all discounts and fees\n * @param {Object} product - Product object\n * @param {number} qty - Quantity\n * @param {boolean} isAnnual - Whether this is an annual commitment\n * @param {boolean} waiveFees - Whether to waive processing fees\n * @param {number} monthlyVolume - Monthly transaction volume\n * @param {number} totalSpend - Total customer spend\n * @param {Object} factors - Dynamic pricing factors\n * @returns {Object} Complete pricing details\n */\nexport const calculateTotalCost = (product, qty, isAnnual, waiveFees, monthlyVolume = 0, totalSpend = 0, factors = {}) => {\n  const pricingData = getPricingData(product, qty);\n  const dynamicPrice = calculateDynamicPricing(pricingData.recommendedPrice, factors);\n  const subtotal = dynamicPrice * qty;\n  const tax = subtotal * FINANCIAL_CONSTANTS.TAX_RATE;\n  const processingFee = calculatePaymentProcessingFee(subtotal + tax, isAnnual, waiveFees, monthlyVolume, totalSpend);\n  const loyaltyTier = getLoyaltyTier(totalSpend);\n  const feeReport = generateFeeReport(processingFee, monthlyVolume, totalSpend);\n  \n  // Calculate commitment level\n  const commitmentLevel = isAnnual ? 'ANNUAL' : 'MONTHLY';\n  const commitmentPricing = calculateCommitmentPricing(dynamicPrice, commitmentLevel, qty);\n  \n  // Get upsell opportunities with dynamic pricing\n  const upsellOpportunities = getUpsellOpportunities([product], commitmentLevel, totalSpend)\n    .map(upsell => ({\n      ...upsell,\n      dynamicPrice: calculateDynamicPricing(upsell.basePrice, factors)\n    }));\n  \n  // Get profit optimization recommendations\n  const profitRecommendations = getProfitOptimizationRecommendations(\n    [product], \n    commitmentLevel, \n    totalSpend\n  );\n  \n  return {\n    subtotal,\n    tax,\n    processingFee: processingFee.fee,\n    total: subtotal + tax + processingFee.fee,\n    discounts: {\n      volume: pricingData.volumeDiscount,\n      seasonal: pricingData.seasonalDiscount,\n      total: pricingData.totalDiscount,\n      commitment: commitmentPricing.discount,\n      dynamic: factors.demandLevel ? \n        (1 - FINANCIAL_CONSTANTS.DYNAMIC_PRICING.DEMAND_BASED[factors.demandLevel].multiplier) * 100 : 0\n    },\n    fees: {\n      processing: processingFee,\n      tax: FINANCIAL_CONSTANTS.TAX_RATE\n    },\n    loyalty: {\n      tier: loyaltyTier.name,\n      benefits: loyaltyTier.benefits\n    },\n    commitment: commitmentPricing,\n    upsellOpportunities,\n    profitRecommendations,\n    feeReport,\n    dynamicPricing: {\n      basePrice: pricingData.recommendedPrice,\n      adjustedPrice: dynamicPrice,\n      factors\n    },\n    isAnnual,\n    quantity: qty\n  };\n};\n\n/**\n * Get business recommendations based on current configuration\n * @param {Array} products - Array of selected products\n * @param {number} serviceCharge - Service charge amount\n * @param {string} billingCycle - Billing cycle (monthly/annual)\n * @param {number} profitBeforeTax - Profit before tax\n * @param {number} totalSpend - Total customer spend\n * @param {number} monthlyVolume - Monthly transaction volume\n * @returns {Array} Array of recommendations\n */\nexport const getRecommendations = (products, serviceCharge, billingCycle, profitBeforeTax, totalSpend = 0, monthlyVolume = 0) => {\n  if (!Array.isArray(products) || typeof serviceCharge !== 'number' || \n      !['monthly', 'annual'].includes(billingCycle) || typeof profitBeforeTax !== 'number') {\n    throw new Error('Invalid input parameters');\n  }\n\n  const recommendations = [];\n  const selectedCategories = products.map(p => p.category);\n  const currentSeason = getCurrentSeasonalPricing();\n  const isAnnual = billingCycle === 'annual';\n\n  // Calculate total amount for fee waiver recommendations\n  const totalAmount = products.reduce((sum, p) => {\n    const pricingData = getPricingData(p, p.qty);\n    return sum + (pricingData.recommendedPrice * p.qty);\n  }, 0);\n\n  // Loyalty tier recommendations\n  const currentTier = getLoyaltyTier(totalSpend);\n  const nextTier = Object.entries(FINANCIAL_CONSTANTS.LOYALTY_TIERS)\n    .find(([, tier]) => tier.minSpend > currentTier.minSpend);\n\n  if (nextTier) {\n    const [, nextTierData] = nextTier;\n    const remainingForNextTier = nextTierData.minSpend - totalSpend;\n    recommendations.push(\n      `Add $${remainingForNextTier.toFixed(2)} more to your total spend to reach ${nextTierData.name} tier and get ${(nextTierData.benefits.processingFeeDiscount * 100).toFixed(0)}% off processing fees.`\n    );\n  }\n\n  // Volume-based fee tier recommendations\n  const currentFeeTier = getProcessingFeeTier(monthlyVolume);\n  const nextFeeTier = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.TIERED_FEES\n    .find(tier => tier.minVolume > currentFeeTier.minVolume);\n\n  if (nextFeeTier) {\n    const remainingForNextTier = nextFeeTier.minVolume - monthlyVolume;\n    recommendations.push(\n      `Increase your monthly volume by $${remainingForNextTier.toFixed(2)} to qualify for lower processing fees (${(nextFeeTier.percentageFee * 100).toFixed(2)}% + $${nextFeeTier.baseFee.toFixed(2)}).`\n    );\n  }\n\n  // Payment processing fee recommendations\n  if (!isAnnual && totalAmount < FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER) {\n    const remainingForWaiver = FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.MIN_AMOUNT_FOR_WAIVER - totalAmount;\n    recommendations.push(\n      `Add $${remainingForWaiver.toFixed(2)} more to your order to qualify for automatic payment processing fee waiver.`\n    );\n  }\n\n  if (!isAnnual && FINANCIAL_CONSTANTS.PAYMENT_PROCESSING.ANNUAL_COMMITMENT_WAIVER) {\n    recommendations.push(\n      \"Switch to annual billing to automatically waive payment processing fees.\"\n    );\n  }\n\n  // Add seasonal pricing recommendation\n  if (currentSeason.discount > 0) {\n    recommendations.push(\n      `Take advantage of our ${currentSeason.name} with ${(currentSeason.discount * 100).toFixed(0)}% off!`\n    );\n  }\n\n  // Volume discount recommendations\n  products.forEach(p => {\n    const nextVolumeTier = FINANCIAL_CONSTANTS.VOLUME_DISCOUNTS\n      .find(tier => tier.minQty > p.qty);\n    \n    if (nextVolumeTier) {\n      const additionalQty = nextVolumeTier.minQty - p.qty;\n      const potentialDiscount = nextVolumeTier.discount;\n      recommendations.push(\n        `Add ${additionalQty} more ${p.name} units to qualify for ${(potentialDiscount * 100).toFixed(0)}% volume discount.`\n      );\n    }\n  });\n\n  // 1. Margin improvement\n  const lowMarginProducts = products.filter(p => getPricingData(p, p.qty).margin < FINANCIAL_CONSTANTS.TARGET_MARGIN);\n  if (lowMarginProducts.length > 0) {\n    lowMarginProducts.forEach(p => {\n      const currentMargin = getPricingData(p, p.qty).margin;\n      recommendations.push(\n        `Increase the margin for \"${p.name}\" (currently ${(currentMargin * 100).toFixed(1)}%) to at least ${(FINANCIAL_CONSTANTS.TARGET_MARGIN * 100).toFixed(1)}% to improve profitability.`\n      );\n    });\n  }\n\n  // 2. Upsell higher-margin products\n  const highMarginProducts = products.filter(p => getPricingData(p, p.qty).margin >= FINANCIAL_CONSTANTS.HIGH_MARGIN);\n  if (highMarginProducts.length > 0) {\n    highMarginProducts.forEach(p => {\n      const margin = getPricingData(p, p.qty).margin;\n      recommendations.push(`Focus on upselling \"${p.name}\" (margin ${(margin * 100).toFixed(1)}%) for better profit.`);\n    });\n  }\n\n  // 3. Bundle services\n  if (products.length > 1) {\n    const bundleDiscount = FINANCIAL_CONSTANTS.ANNUAL_DISCOUNT_RATE * 100;\n    recommendations.push(\n      `Bundle multiple products/services for a more attractive offer. Consider offering a ${bundleDiscount}% discount for annual commitments.`\n    );\n  }\n\n  // 4. Service charge review\n  if (serviceCharge < FINANCIAL_CONSTANTS.MIN_SERVICE_FEE) {\n    recommendations.push(\n      `Consider increasing your Professional Services & Support fee to at least $${FINANCIAL_CONSTANTS.MIN_SERVICE_FEE}/year to match industry averages.`\n    );\n  }\n\n  // 5. Profitability check\n  if (profitBeforeTax < 0) {\n    recommendations.push(\"Warning: Your current configuration is not profitable. Review your pricing and costs.\");\n  } else if (profitBeforeTax < FINANCIAL_CONSTANTS.MIN_PROFIT_THRESHOLD) {\n    recommendations.push(\n      `Your profit ($${profitBeforeTax.toFixed(2)}) is below the recommended threshold of $${FINANCIAL_CONSTANTS.MIN_PROFIT_THRESHOLD}. Consider increasing margins or service fees, or reducing costs.`\n    );\n  } else {\n    recommendations.push(\n      `Your configuration is profitable ($${profitBeforeTax.toFixed(2)}). Look for further upsell opportunities or cost optimizations.`\n    );\n  }\n\n  // 6. Complementary product recommendations\n  const complementaryCategories = {\n    Desktop: [\"Server\", \"SaaS\"],\n    Server: [\"SaaS\", \"Virtual Server\"],\n    \"Virtual Server\": [\"SaaS\"],\n    SaaS: [\"Server\", \"Virtual Server\"],\n  };\n\n  const missingCategories = Object.entries(complementaryCategories)\n    .filter(([category]) => selectedCategories.includes(category))\n    .flatMap(([, compCategories]) => \n      compCategories.filter(cat => !selectedCategories.includes(cat))\n    )\n    .filter((cat, index, self) => self.indexOf(cat) === index);\n\n  if (missingCategories.length > 0) {\n    const suggestedProduct = products.find(p => missingCategories.includes(p.category));\n    if (suggestedProduct) {\n      const potentialRevenue = formatCurrency(suggestedProduct.pricingSlabs[0].recommendedPrice * 5);\n      const annualRevenue = billingCycle === 'annual' ? \n        formatCurrency(potentialRevenue * 12) : \n        potentialRevenue;\n      \n      recommendations.push(\n        `Enhance your solution by adding a \"${suggestedProduct.category}\" product like \"${suggestedProduct.name}\". ` +\n        `This can provide a more comprehensive backup strategy and increase your revenue by approximately $${annualRevenue} ${billingCycle === 'annual' ? 'per year' : 'per month'} for 5 units.`\n      );\n    }\n  }\n\n  return recommendations;\n};\n\n/**\n * Calculate all derived fields for a product row (unit cost, margin, price, total, etc.)\n * @param {Product} product\n * @param {number} qty\n * @param {string} billingCycle\n * @returns {Object}\n */\nexport function calculateProductRow(product, qty, billingCycle) {\n  const isDR = product.isHomeGrown;\n  // Find the correct pricing slab\n  const slab = (product.pricingSlabs || []).find(\n    slab => qty >= slab.minQty && qty <= slab.maxQty\n  ) || (product.pricingSlabs ? product.pricingSlabs[product.pricingSlabs.length - 1] : { unitCost: 0, margin: 0, recommendedPrice: 0 });\n  // For non-DR, display unitCost with 13% tax for UI\n  let unitCost = typeof product.unitCost === 'number' ? product.unitCost : slab.unitCost;\n  if (!isDR) {\n    unitCost = unitCost * 1.13;\n  }\n  const margin = typeof product.margin === 'number' ? product.margin : (slab.margin || 0);\n  // DR: price = unitCost * 1.13, others: unitCost * (1 + margin/100)\n  const price = isDR ? unitCost : unitCost * (1 + margin / 100);\n  // For DR, total is price (not price * qty), for others, total = price * qty * billingMultiplier\n  const billingMultiplier = billingCycle === 'annual' ? 12 : 1;\n  const total = isDR ? price : price * qty * billingMultiplier;\n  return {\n    ...product,\n    qty,\n    unitCost,\n    margin,\n    price,\n    total,\n    isDR,\n    slab\n  };\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}